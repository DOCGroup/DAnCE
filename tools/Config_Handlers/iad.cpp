/*
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please report this to the XSC project at
 * https://github.com/DOCGroup/XSC
 */
#include "iad.hpp"

#include "ace/Null_Mutex.h"
#include "ace/TSS_T.h"
#include "ace/ace_wchar.h"
#include "ace/Singleton.h"

namespace DAnCE
{
  namespace Config_Handlers
  {
    // NamedImplementationArtifact

    NamedImplementationArtifact::NamedImplementationArtifact (::XMLSchema::string<ACE_TCHAR> const& name__,
                                                              ::DAnCE::Config_Handlers::ImplementationArtifactDescription const& referencedArtifact__) :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string<ACE_TCHAR> (name__)),
    referencedArtifact_ (new ::DAnCE::Config_Handlers::ImplementationArtifactDescription (referencedArtifact__)),
    regulator__ ()
    {
      name_->container (this);
      referencedArtifact_->container (this);
    }

    NamedImplementationArtifact::NamedImplementationArtifact (NamedImplementationArtifact const& s) :
    ::XSCRT::Type (s),
    name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_)),
    referencedArtifact_ (new ::DAnCE::Config_Handlers::ImplementationArtifactDescription (*s.referencedArtifact_)),
    regulator__ ()
    {
      name_->container (this);
      referencedArtifact_->container (this);
    }

    NamedImplementationArtifact&
    NamedImplementationArtifact::operator= (NamedImplementationArtifact const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        referencedArtifact (*s.referencedArtifact_);
      }

      return *this;
    }


    // NamedImplementationArtifact
    ::XMLSchema::string<ACE_TCHAR> const& NamedImplementationArtifact::
    name () const
    {
      return *name_;
    }

    void NamedImplementationArtifact::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // NamedImplementationArtifact
    ::DAnCE::Config_Handlers::ImplementationArtifactDescription const& NamedImplementationArtifact::
    referencedArtifact () const
    {
      return *referencedArtifact_;
    }

    void NamedImplementationArtifact::
    referencedArtifact (::DAnCE::Config_Handlers::ImplementationArtifactDescription const& e)
    {
      *referencedArtifact_ = e;
    }


    // ImplementationArtifactDescription

    ImplementationArtifactDescription::ImplementationArtifactDescription () :
    ::XSCRT::Type (),
    regulator__ ()
    {
    }

    ImplementationArtifactDescription::ImplementationArtifactDescription (ImplementationArtifactDescription const& s) :
    ::XSCRT::Type (s),
    label_ (s.label_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.label_) : 0),
    UUID_ (s.UUID_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.UUID_) : 0),
    location_ (s.location_),
    dependsOn_ (s.dependsOn_),
    execParameter_ (s.execParameter_),
    infoProperty_ (s.infoProperty_),
    deployRequirement_ (s.deployRequirement_),
    contentLocation_ (s.contentLocation_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.contentLocation_) : 0),
    href_ (s.href_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.href_) : 0),
    regulator__ ()
    {
      if (label_.get ()) label_->container (this);
      if (UUID_.get ()) UUID_->container (this);
      if (contentLocation_.get ()) contentLocation_->container (this);
      if (href_.get ()) href_->container (this);
    }

    ImplementationArtifactDescription&
    ImplementationArtifactDescription::operator= (ImplementationArtifactDescription const& s)
    {
      if (&s != this)
      {
        if (s.label_.get ())
          label (*(s.label_));
        else
          label_.reset (0);

        if (s.UUID_.get ())
          UUID (*(s.UUID_));
        else
          UUID_.reset (0);

        location_ = s.location_;

        dependsOn_ = s.dependsOn_;

        execParameter_ = s.execParameter_;

        infoProperty_ = s.infoProperty_;

        deployRequirement_ = s.deployRequirement_;

        if (s.contentLocation_.get ())
          contentLocation (*(s.contentLocation_));
        else
          contentLocation_.reset (0);

        if (s.href_.get ()) href (*(s.href_));
        else href_.reset (0);
      }

      return *this;
    }


    // ImplementationArtifactDescription
    bool ImplementationArtifactDescription::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ImplementationArtifactDescription::
    label () const
    {
      return *label_;
    }

    void ImplementationArtifactDescription::
    label (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = ImplementationArtifactDescription::label_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        label_->container (this);
      }
    }

    // ImplementationArtifactDescription
    bool ImplementationArtifactDescription::
    UUID_p () const
    {
      return UUID_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ImplementationArtifactDescription::
    UUID () const
    {
      return *UUID_;
    }

    void ImplementationArtifactDescription::
    UUID (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (UUID_.get ())
      {
        *UUID_ = e;
      }

      else
      {
        UUID_ = ImplementationArtifactDescription::UUID_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        UUID_->container (this);
      }
    }

    // ImplementationArtifactDescription
    ImplementationArtifactDescription::location_iterator ImplementationArtifactDescription::
    begin_location ()
    {
      return location_.begin ();
    }

    ImplementationArtifactDescription::location_iterator ImplementationArtifactDescription::
    end_location ()
    {
      return location_.end ();
    }

    ImplementationArtifactDescription::location_const_iterator ImplementationArtifactDescription::
    begin_location () const
    {
      return location_.begin ();
    }

    ImplementationArtifactDescription::location_const_iterator ImplementationArtifactDescription::
    end_location () const
    {
      return location_.end ();
    }

    void ImplementationArtifactDescription::
    add_location (ImplementationArtifactDescription::location_value_type const& e)
    {
      location_.push_back (e);
    }

    size_t ImplementationArtifactDescription::
    count_location(void) const
    {
      return location_.size ();
    }

    // ImplementationArtifactDescription
    ImplementationArtifactDescription::dependsOn_iterator ImplementationArtifactDescription::
    begin_dependsOn ()
    {
      return dependsOn_.begin ();
    }

    ImplementationArtifactDescription::dependsOn_iterator ImplementationArtifactDescription::
    end_dependsOn ()
    {
      return dependsOn_.end ();
    }

    ImplementationArtifactDescription::dependsOn_const_iterator ImplementationArtifactDescription::
    begin_dependsOn () const
    {
      return dependsOn_.begin ();
    }

    ImplementationArtifactDescription::dependsOn_const_iterator ImplementationArtifactDescription::
    end_dependsOn () const
    {
      return dependsOn_.end ();
    }

    void ImplementationArtifactDescription::
    add_dependsOn (ImplementationArtifactDescription::dependsOn_value_type const& e)
    {
      dependsOn_.push_back (e);
    }

    size_t ImplementationArtifactDescription::
    count_dependsOn(void) const
    {
      return dependsOn_.size ();
    }

    // ImplementationArtifactDescription
    ImplementationArtifactDescription::execParameter_iterator ImplementationArtifactDescription::
    begin_execParameter ()
    {
      return execParameter_.begin ();
    }

    ImplementationArtifactDescription::execParameter_iterator ImplementationArtifactDescription::
    end_execParameter ()
    {
      return execParameter_.end ();
    }

    ImplementationArtifactDescription::execParameter_const_iterator ImplementationArtifactDescription::
    begin_execParameter () const
    {
      return execParameter_.begin ();
    }

    ImplementationArtifactDescription::execParameter_const_iterator ImplementationArtifactDescription::
    end_execParameter () const
    {
      return execParameter_.end ();
    }

    void ImplementationArtifactDescription::
    add_execParameter (ImplementationArtifactDescription::execParameter_value_type const& e)
    {
      execParameter_.push_back (e);
    }

    size_t ImplementationArtifactDescription::
    count_execParameter(void) const
    {
      return execParameter_.size ();
    }

    // ImplementationArtifactDescription
    ImplementationArtifactDescription::infoProperty_iterator ImplementationArtifactDescription::
    begin_infoProperty ()
    {
      return infoProperty_.begin ();
    }

    ImplementationArtifactDescription::infoProperty_iterator ImplementationArtifactDescription::
    end_infoProperty ()
    {
      return infoProperty_.end ();
    }

    ImplementationArtifactDescription::infoProperty_const_iterator ImplementationArtifactDescription::
    begin_infoProperty () const
    {
      return infoProperty_.begin ();
    }

    ImplementationArtifactDescription::infoProperty_const_iterator ImplementationArtifactDescription::
    end_infoProperty () const
    {
      return infoProperty_.end ();
    }

    void ImplementationArtifactDescription::
    add_infoProperty (ImplementationArtifactDescription::infoProperty_value_type const& e)
    {
      infoProperty_.push_back (e);
    }

    size_t ImplementationArtifactDescription::
    count_infoProperty(void) const
    {
      return infoProperty_.size ();
    }

    // ImplementationArtifactDescription
    ImplementationArtifactDescription::deployRequirement_iterator ImplementationArtifactDescription::
    begin_deployRequirement ()
    {
      return deployRequirement_.begin ();
    }

    ImplementationArtifactDescription::deployRequirement_iterator ImplementationArtifactDescription::
    end_deployRequirement ()
    {
      return deployRequirement_.end ();
    }

    ImplementationArtifactDescription::deployRequirement_const_iterator ImplementationArtifactDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.begin ();
    }

    ImplementationArtifactDescription::deployRequirement_const_iterator ImplementationArtifactDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.end ();
    }

    void ImplementationArtifactDescription::
    add_deployRequirement (ImplementationArtifactDescription::deployRequirement_value_type const& e)
    {
      deployRequirement_.push_back (e);
    }

    size_t ImplementationArtifactDescription::
    count_deployRequirement(void) const
    {
      return deployRequirement_.size ();
    }

    // ImplementationArtifactDescription
    bool ImplementationArtifactDescription::
    contentLocation_p () const
    {
      return contentLocation_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ImplementationArtifactDescription::
    contentLocation () const
    {
      return *contentLocation_;
    }

    void ImplementationArtifactDescription::
    contentLocation (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (contentLocation_.get ())
      {
        *contentLocation_ = e;
      }

      else
      {
        contentLocation_ = ImplementationArtifactDescription::contentLocation_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        contentLocation_->container (this);
      }
    }

    // ImplementationArtifactDescription
    bool ImplementationArtifactDescription::
    href_p () const
    {
      return href_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ImplementationArtifactDescription::
    href () const
    {
      return *href_;
    }

    ::XMLSchema::string<ACE_TCHAR>& ImplementationArtifactDescription::
    href ()
    {
      return *href_;
    }

    void ImplementationArtifactDescription::
    href (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (href_.get ())
      {
        *href_ = e;
      }

      else
      {
        href_ = ImplementationArtifactDescription::href_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        href_->container (this);
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    // NamedImplementationArtifact

    NamedImplementationArtifact::
    NamedImplementationArtifact (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = NamedImplementationArtifact::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("referencedArtifact"))
        {
          referencedArtifact_ = NamedImplementationArtifact::referencedArtifact_auto_ptr_type (new ::DAnCE::Config_Handlers::ImplementationArtifactDescription (e));
          referencedArtifact_->container (this);
        }

        else
        {
        }
      }
    }

    // ImplementationArtifactDescription

    ImplementationArtifactDescription::
    ImplementationArtifactDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("label"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          label (t);
        }

        else if (n == ACE_TEXT("UUID"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          UUID (t);
        }

        else if (n == ACE_TEXT("location"))
        {
          location_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_location (t);
        }

        else if (n == ACE_TEXT("dependsOn"))
        {
          dependsOn_value_type t (new ::DAnCE::Config_Handlers::NamedImplementationArtifact (e));
          add_dependsOn (t);
        }

        else if (n == ACE_TEXT("execParameter"))
        {
          execParameter_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_execParameter (t);
        }

        else if (n == ACE_TEXT("infoProperty"))
        {
          infoProperty_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_infoProperty (t);
        }

        else if (n == ACE_TEXT("deployRequirement"))
        {
          deployRequirement_value_type t (new ::DAnCE::Config_Handlers::Requirement (e));
          add_deployRequirement (t);
        }

        else if (n == ACE_TEXT("contentLocation"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          contentLocation (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("href"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (a);
          href (t);
        }

        else
        {
        }
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

