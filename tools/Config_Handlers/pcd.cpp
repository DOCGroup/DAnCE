/*
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please report this to the XSC project at
 * https://github.com/DOCGroup/XSC
 */
#include "pcd.hpp"

#include "ace/ace_wchar.h"
#include "ace/Null_Mutex.h"
#include "ace/TSS_T.h"
#include "ace/Singleton.h"

namespace DAnCE
{
  namespace Config_Handlers
  {
    // ComponentPackageImport

    ComponentPackageImport::ComponentPackageImport ()
    : ::XSCRT::Type ()
    {
    }

    ComponentPackageImport::ComponentPackageImport (ComponentPackageImport const& s) :
    ::XSCRT::Type (s)
    , location_ (s.location_)
    {
    }

    ComponentPackageImport&
    ComponentPackageImport::operator= (ComponentPackageImport const& s)
    {
      if (&s != this)
      {
        location_ = s.location_;
      }

      return *this;
    }


    // ComponentPackageImport
    ComponentPackageImport::location_iterator ComponentPackageImport::
    begin_location ()
    {
      return location_.begin ();
    }

    ComponentPackageImport::location_iterator ComponentPackageImport::
    end_location ()
    {
      return location_.end ();
    }

    ComponentPackageImport::location_const_iterator ComponentPackageImport::
    begin_location () const
    {
      return location_.begin ();
    }

    ComponentPackageImport::location_const_iterator ComponentPackageImport::
    end_location () const
    {
      return location_.end ();
    }

    void ComponentPackageImport::
    add_location (ComponentPackageImport::location_value_type const& e)
    {
      location_.push_back (e);
    }

    size_t ComponentPackageImport::
    count_location(void) const
    {
      return location_.size ();
    }


    // PackageConfiguration

    PackageConfiguration::PackageConfiguration ()
    : ::XSCRT::Type ()
    {
    }

    PackageConfiguration::PackageConfiguration (PackageConfiguration const& s) :
    ::XSCRT::Type (s)
    , label_ (s.label_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.label_) : 0)
    , UUID_ (s.UUID_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.UUID_) : 0)
    , basePackage_ (s.basePackage_.get () ? new ::DAnCE::Config_Handlers::ComponentPackageDescription (*s.basePackage_) : 0)
    , specializedConfig_ (s.specializedConfig_.get () ? new ::DAnCE::Config_Handlers::PackageConfiguration (*s.specializedConfig_) : 0)
    , importedPackage_ (s.importedPackage_.get () ? new ::DAnCE::Config_Handlers::ComponentPackageImport (*s.importedPackage_) : 0)
    , referencedPackage_ (s.referencedPackage_.get () ? new ::DAnCE::Config_Handlers::ComponentPackageReference (*s.referencedPackage_) : 0)
    , selectRequirement_ (s.selectRequirement_)
    , configProperty_ (s.configProperty_)
    , contentLocation_ (s.contentLocation_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.contentLocation_) : 0)
    {
      if (label_.get ()) label_->container (this);
      if (UUID_.get ()) UUID_->container (this);
      if (basePackage_.get ()) basePackage_->container (this);
      if (specializedConfig_.get ()) specializedConfig_->container (this);
      if (importedPackage_.get ()) importedPackage_->container (this);
      if (referencedPackage_.get ()) referencedPackage_->container (this);
      if (contentLocation_.get ()) contentLocation_->container (this);
    }

    PackageConfiguration&
    PackageConfiguration::operator= (PackageConfiguration const& s)
    {
      if (&s != this)
      {
        if (s.label_.get ())
          label (*(s.label_));
        else
          label_.reset (0);

        if (s.UUID_.get ())
          UUID (*(s.UUID_));
        else
          UUID_.reset (0);

        if (s.basePackage_.get ())
          basePackage (*(s.basePackage_));
        else
          basePackage_.reset (0);

        if (s.specializedConfig_.get ())
          specializedConfig (*(s.specializedConfig_));
        else
          specializedConfig_.reset (0);

        if (s.importedPackage_.get ())
          importedPackage (*(s.importedPackage_));
        else
          importedPackage_.reset (0);

        if (s.referencedPackage_.get ())
          referencedPackage (*(s.referencedPackage_));
        else
          referencedPackage_.reset (0);

        selectRequirement_ = s.selectRequirement_;

        configProperty_ = s.configProperty_;

        if (s.contentLocation_.get ())
          contentLocation (*(s.contentLocation_));
        else
          contentLocation_.reset (0);
      }

      return *this;
    }


    // PackageConfiguration
    bool PackageConfiguration::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& PackageConfiguration::
    label () const
    {
      return *label_;
    }

    void PackageConfiguration::
    label (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = PackageConfiguration::label_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        label_->container (this);
      }
    }

    // PackageConfiguration
    bool PackageConfiguration::
    UUID_p () const
    {
      return UUID_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& PackageConfiguration::
    UUID () const
    {
      return *UUID_;
    }

    void PackageConfiguration::
    UUID (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (UUID_.get ())
      {
        *UUID_ = e;
      }

      else
      {
        UUID_ = PackageConfiguration::UUID_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        UUID_->container (this);
      }
    }

    // PackageConfiguration
    bool PackageConfiguration::
    basePackage_p () const
    {
      return basePackage_.get () != 0;
    }

    ::DAnCE::Config_Handlers::ComponentPackageDescription const& PackageConfiguration::
    basePackage () const
    {
      return *basePackage_;
    }

    void PackageConfiguration::
    basePackage (::DAnCE::Config_Handlers::ComponentPackageDescription const& e)
    {
      if (basePackage_.get ())
      {
        *basePackage_ = e;
      }

      else
      {
        basePackage_ = PackageConfiguration::basePackage_auto_ptr_type (new ::DAnCE::Config_Handlers::ComponentPackageDescription (e));
        basePackage_->container (this);
      }
    }

    // PackageConfiguration
    bool PackageConfiguration::
    specializedConfig_p () const
    {
      return specializedConfig_.get () != 0;
    }

    ::DAnCE::Config_Handlers::PackageConfiguration const& PackageConfiguration::
    specializedConfig () const
    {
      return *specializedConfig_;
    }

    void PackageConfiguration::
    specializedConfig (::DAnCE::Config_Handlers::PackageConfiguration const& e)
    {
      if (specializedConfig_.get ())
      {
        *specializedConfig_ = e;
      }

      else
      {
        specializedConfig_ = PackageConfiguration::specializedConfig_auto_ptr_type (new ::DAnCE::Config_Handlers::PackageConfiguration (e));
        specializedConfig_->container (this);
      }
    }

    // PackageConfiguration
    bool PackageConfiguration::
    importedPackage_p () const
    {
      return importedPackage_.get () != 0;
    }

    ::DAnCE::Config_Handlers::ComponentPackageImport const& PackageConfiguration::
    importedPackage () const
    {
      return *importedPackage_;
    }

    void PackageConfiguration::
    importedPackage (::DAnCE::Config_Handlers::ComponentPackageImport const& e)
    {
      if (importedPackage_.get ())
      {
        *importedPackage_ = e;
      }

      else
      {
        importedPackage_ = PackageConfiguration::importedPackage_auto_ptr_type (new ::DAnCE::Config_Handlers::ComponentPackageImport (e));
        importedPackage_->container (this);
      }
    }

    // PackageConfiguration
    bool PackageConfiguration::
    referencedPackage_p () const
    {
      return referencedPackage_.get () != 0;
    }

    ::DAnCE::Config_Handlers::ComponentPackageReference const& PackageConfiguration::
    referencedPackage () const
    {
      return *referencedPackage_;
    }

    void PackageConfiguration::
    referencedPackage (::DAnCE::Config_Handlers::ComponentPackageReference const& e)
    {
      if (referencedPackage_.get ())
      {
        *referencedPackage_ = e;
      }

      else
      {
        referencedPackage_ = PackageConfiguration::referencedPackage_auto_ptr_type (new ::DAnCE::Config_Handlers::ComponentPackageReference (e));
        referencedPackage_->container (this);
      }
    }

    // PackageConfiguration
    PackageConfiguration::selectRequirement_iterator PackageConfiguration::
    begin_selectRequirement ()
    {
      return selectRequirement_.begin ();
    }

    PackageConfiguration::selectRequirement_iterator PackageConfiguration::
    end_selectRequirement ()
    {
      return selectRequirement_.end ();
    }

    PackageConfiguration::selectRequirement_const_iterator PackageConfiguration::
    begin_selectRequirement () const
    {
      return selectRequirement_.begin ();
    }

    PackageConfiguration::selectRequirement_const_iterator PackageConfiguration::
    end_selectRequirement () const
    {
      return selectRequirement_.end ();
    }

    void PackageConfiguration::
    add_selectRequirement (PackageConfiguration::selectRequirement_value_type const& e)
    {
      selectRequirement_.push_back (e);
    }

    size_t PackageConfiguration::
    count_selectRequirement(void) const
    {
      return selectRequirement_.size ();
    }

    // PackageConfiguration
    PackageConfiguration::configProperty_iterator PackageConfiguration::
    begin_configProperty ()
    {
      return configProperty_.begin ();
    }

    PackageConfiguration::configProperty_iterator PackageConfiguration::
    end_configProperty ()
    {
      return configProperty_.end ();
    }

    PackageConfiguration::configProperty_const_iterator PackageConfiguration::
    begin_configProperty () const
    {
      return configProperty_.begin ();
    }

    PackageConfiguration::configProperty_const_iterator PackageConfiguration::
    end_configProperty () const
    {
      return configProperty_.end ();
    }

    void PackageConfiguration::
    add_configProperty (PackageConfiguration::configProperty_value_type const& e)
    {
      configProperty_.push_back (e);
    }

    size_t PackageConfiguration::
    count_configProperty(void) const
    {
      return configProperty_.size ();
    }

    // PackageConfiguration
    bool PackageConfiguration::
    contentLocation_p () const
    {
      return contentLocation_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& PackageConfiguration::
    contentLocation () const
    {
      return *contentLocation_;
    }

    void PackageConfiguration::
    contentLocation (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (contentLocation_.get ())
      {
        *contentLocation_ = e;
      }

      else
      {
        contentLocation_ = PackageConfiguration::contentLocation_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        contentLocation_->container (this);
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    // ComponentPackageImport

    ComponentPackageImport::
    ComponentPackageImport (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("location"))
        {
          location_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_location (t);
        }

        else
        {
        }
      }
    }

    // PackageConfiguration

    PackageConfiguration::
    PackageConfiguration (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("label"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          label (t);
        }

        else if (n == ACE_TEXT("UUID"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          UUID (t);
        }

        else if (n == ACE_TEXT("basePackage"))
        {
          ::DAnCE::Config_Handlers::ComponentPackageDescription t (e);
          basePackage (t);
        }

        else if (n == ACE_TEXT("specializedConfig"))
        {
          ::DAnCE::Config_Handlers::PackageConfiguration t (e);
          specializedConfig (t);
        }

        else if (n == ACE_TEXT("importedPackage"))
        {
          ::DAnCE::Config_Handlers::ComponentPackageImport t (e);
          importedPackage (t);
        }

        else if (n == ACE_TEXT("referencedPackage"))
        {
          ::DAnCE::Config_Handlers::ComponentPackageReference t (e);
          referencedPackage (t);
        }

        else if (n == ACE_TEXT("selectRequirement"))
        {
          selectRequirement_value_type t (new ::DAnCE::Config_Handlers::Requirement (e));
          add_selectRequirement (t);
        }

        else if (n == ACE_TEXT("configProperty"))
        {
          configProperty_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_configProperty (t);
        }

        else if (n == ACE_TEXT("contentLocation"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          contentLocation (t);
        }

        else
        {
        }
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

