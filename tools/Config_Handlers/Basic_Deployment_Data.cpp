/*
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please report this to the XSC project at
 * https://github.com/DOCGroup/XSC
 */
#include "Basic_Deployment_Data.hpp"

#include "ace/ace_wchar.h"
#include "ace/Null_Mutex.h"
#include "ace/TSS_T.h"
#include "ace/Singleton.h"

namespace DAnCE
{
  namespace Config_Handlers
  {
    // IdRef

    IdRef::IdRef ()
    {
    }

    IdRef::IdRef (IdRef const& s) :
    ::XSCRT::Type (s)
    , href_ (s.href_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.href_) : 0)
    , idref_ (s.idref_.get () ? new ::XMLSchema::IDREF<ACE_TCHAR> (*s.idref_) : 0)
    {
      if (href_.get ()) href_->container (this);
      if (idref_.get ()) idref_->container (this);
    }

    IdRef&
    IdRef::operator= (IdRef const& s)
    {
      if (&s != this)
      {
        if (s.href_.get ()) href (*(s.href_));
        else href_.reset (0);

        if (s.idref_.get ()) idref (*(s.idref_));
        else idref_.reset (0);
      }

      return *this;
    }


    // IdRef
    bool IdRef::
    href_p () const
    {
      return href_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& IdRef::
    href () const
    {
      return *href_;
    }

    ::XMLSchema::string<ACE_TCHAR>& IdRef::
    href ()
    {
      return *href_;
    }

    void IdRef::
    href (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (href_.get ())
      {
        *href_ = e;
      }

      else
      {
        href_ = IdRef::href_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        href_->container (this);
      }
    }

    // IdRef
    bool IdRef::
    idref_p () const
    {
      return idref_.get () != 0;
    }

    ::XMLSchema::IDREF<ACE_TCHAR> const& IdRef::
    idref () const
    {
      return *idref_;
    }

    ::XMLSchema::IDREF<ACE_TCHAR>& IdRef::
    idref ()
    {
      return *idref_;
    }

    ::XSCRT::Type* IdRef::get_idref_ptr ()
    {
      std::basic_string<ACE_TCHAR> temp (idref().id());
      return this->get_idref(temp.c_str ());
    }


    void IdRef::set_idref_ptr (const std::basic_string<ACE_TCHAR>& idref)
    {
        ID_Map::TSS_ID_Map* TSS_ID_Map (ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance());
        (*TSS_ID_Map)->resolve_single_idref(idref, this);
    }


    void IdRef::
    idref (::XMLSchema::IDREF<ACE_TCHAR> const& e)
    {
      if (idref_.get ())
      {
        *idref_ = e;
      }

      else
      {
        idref_ = IdRef::idref_auto_ptr_type (new ::XMLSchema::IDREF<ACE_TCHAR> (e));
        idref_->container (this);
      }
    }


    // TCKind

    TCKind::Value TCKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::TCKind const& a, ::DAnCE::Config_Handlers::TCKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::TCKind const& a, ::DAnCE::Config_Handlers::TCKind const& b)
    {
      return a.v_ != b.v_;
    }

    TCKind::
    TCKind (TCKind::Value v)
    : v_ (v)
    {
    }

    // DataType

    DataType::DataType (::DAnCE::Config_Handlers::TCKind const& kind__)
    : ::XSCRT::Type ()
    , kind_ (new ::DAnCE::Config_Handlers::TCKind (kind__))
    {
      kind_->container (this);
    }

    DataType::DataType (DataType const& s) :
    ::XSCRT::Type (s)
    , kind_ (new ::DAnCE::Config_Handlers::TCKind (*s.kind_))
    , enum__ (s.enum__.get () ? new ::DAnCE::Config_Handlers::EnumType (*s.enum__) : 0)
    , struct__ (s.struct__.get () ? new ::DAnCE::Config_Handlers::StructType (*s.struct__) : 0)
    , value_ (s.value_.get () ? new ::DAnCE::Config_Handlers::ValueType (*s.value_) : 0)
    , sequence_ (s.sequence_.get () ? new ::DAnCE::Config_Handlers::SequenceType (*s.sequence_) : 0)
    , alias_ (s.alias_.get () ? new ::DAnCE::Config_Handlers::AliasType (*s.alias_) : 0)
    , array_ (s.array_.get () ? new ::DAnCE::Config_Handlers::ArrayType (*s.array_) : 0)
    , boundedString_ (s.boundedString_.get () ? new ::DAnCE::Config_Handlers::BoundedStringType (*s.boundedString_) : 0)
    , id_ (s.id_.get () ? new ::XMLSchema::ID<ACE_TCHAR> (*s.id_) : 0)
    {
      kind_->container (this);
      if (enum__.get ()) enum__->container (this);
      if (struct__.get ()) struct__->container (this);
      if (value_.get ()) value_->container (this);
      if (sequence_.get ()) sequence_->container (this);
      if (alias_.get ()) alias_->container (this);
      if (array_.get ()) array_->container (this);
      if (boundedString_.get ()) boundedString_->container (this);
      if (id_.get ()) id_->container (this);
    }

    DataType&
    DataType::operator= (DataType const& s)
    {
      if (&s != this)
      {
        kind (*s.kind_);

        if (s.enum__.get ())
          enum_ (*(s.enum__));
        else
          enum__.reset (0);

        if (s.struct__.get ())
          struct_ (*(s.struct__));
        else
          struct__.reset (0);

        if (s.value_.get ())
          value (*(s.value_));
        else
          value_.reset (0);

        if (s.sequence_.get ())
          sequence (*(s.sequence_));
        else
          sequence_.reset (0);

        if (s.alias_.get ())
          alias (*(s.alias_));
        else
          alias_.reset (0);

        if (s.array_.get ())
          array (*(s.array_));
        else
          array_.reset (0);

        if (s.boundedString_.get ())
          boundedString (*(s.boundedString_));
        else
          boundedString_.reset (0);

        if (s.id_.get ()) id (*(s.id_));
        else id_.reset (0);
      }

      return *this;
    }


    // DataType
    ::DAnCE::Config_Handlers::TCKind const& DataType::
    kind () const
    {
      return *kind_;
    }

    void DataType::
    kind (::DAnCE::Config_Handlers::TCKind const& e)
    {
      *kind_ = e;
    }

    // DataType
    bool DataType::
    enum_p () const
    {
      return enum__.get () != 0;
    }

    ::DAnCE::Config_Handlers::EnumType const& DataType::
    enum_ () const
    {
      return *enum__;
    }

    void DataType::
    enum_ (::DAnCE::Config_Handlers::EnumType const& e)
    {
      if (enum__.get ())
      {
        *enum__ = e;
      }

      else
      {
        enum__ = DataType::enum__auto_ptr_type (new ::DAnCE::Config_Handlers::EnumType (e));
        enum__->container (this);
      }
    }

    // DataType
    bool DataType::
    struct_p () const
    {
      return struct__.get () != 0;
    }

    ::DAnCE::Config_Handlers::StructType const& DataType::
    struct_ () const
    {
      return *struct__;
    }

    void DataType::
    struct_ (::DAnCE::Config_Handlers::StructType const& e)
    {
      if (struct__.get ())
      {
        *struct__ = e;
      }

      else
      {
        struct__ = DataType::struct__auto_ptr_type (new ::DAnCE::Config_Handlers::StructType (e));
        struct__->container (this);
      }
    }

    // DataType
    bool DataType::
    value_p () const
    {
      return value_.get () != 0;
    }

    ::DAnCE::Config_Handlers::ValueType const& DataType::
    value () const
    {
      return *value_;
    }

    void DataType::
    value (::DAnCE::Config_Handlers::ValueType const& e)
    {
      if (value_.get ())
      {
        *value_ = e;
      }

      else
      {
        value_ = DataType::value_auto_ptr_type (new ::DAnCE::Config_Handlers::ValueType (e));
        value_->container (this);
      }
    }

    // DataType
    bool DataType::
    sequence_p () const
    {
      return sequence_.get () != 0;
    }

    ::DAnCE::Config_Handlers::SequenceType const& DataType::
    sequence () const
    {
      return *sequence_;
    }

    void DataType::
    sequence (::DAnCE::Config_Handlers::SequenceType const& e)
    {
      if (sequence_.get ())
      {
        *sequence_ = e;
      }

      else
      {
        sequence_ = DataType::sequence_auto_ptr_type (new ::DAnCE::Config_Handlers::SequenceType (e));
        sequence_->container (this);
      }
    }

    // DataType
    bool DataType::
    alias_p () const
    {
      return alias_.get () != 0;
    }

    ::DAnCE::Config_Handlers::AliasType const& DataType::
    alias () const
    {
      return *alias_;
    }

    void DataType::
    alias (::DAnCE::Config_Handlers::AliasType const& e)
    {
      if (alias_.get ())
      {
        *alias_ = e;
      }

      else
      {
        alias_ = DataType::alias_auto_ptr_type (new ::DAnCE::Config_Handlers::AliasType (e));
        alias_->container (this);
      }
    }

    // DataType
    bool DataType::
    array_p () const
    {
      return array_.get () != 0;
    }

    ::DAnCE::Config_Handlers::ArrayType const& DataType::
    array () const
    {
      return *array_;
    }

    void DataType::
    array (::DAnCE::Config_Handlers::ArrayType const& e)
    {
      if (array_.get ())
      {
        *array_ = e;
      }

      else
      {
        array_ = DataType::array_auto_ptr_type (new ::DAnCE::Config_Handlers::ArrayType (e));
        array_->container (this);
      }
    }

    // DataType
    bool DataType::
    boundedString_p () const
    {
      return boundedString_.get () != 0;
    }

    ::DAnCE::Config_Handlers::BoundedStringType const& DataType::
    boundedString () const
    {
      return *boundedString_;
    }

    void DataType::
    boundedString (::DAnCE::Config_Handlers::BoundedStringType const& e)
    {
      if (boundedString_.get ())
      {
        *boundedString_ = e;
      }

      else
      {
        boundedString_ = DataType::boundedString_auto_ptr_type (new ::DAnCE::Config_Handlers::BoundedStringType (e));
        boundedString_->container (this);
      }
    }

    // DataType
    bool DataType::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID<ACE_TCHAR> const& DataType::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID<ACE_TCHAR>& DataType::
    id ()
    {
      return *id_;
    }

    void DataType::
    id (::XMLSchema::ID<ACE_TCHAR> const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = DataType::id_auto_ptr_type (new ::XMLSchema::ID<ACE_TCHAR> (e));
        id_->container (this);
      }
    }


    // DataValue

    DataValue::DataValue ()
    : ::XSCRT::Type ()
    {
    }

    DataValue::DataValue (DataValue const& s) :
    ::XSCRT::Type (s)
    , short__ (s.short__)
    , long__ (s.long__)
    , ushort_ (s.ushort_)
    , ulong_ (s.ulong_)
    , float__ (s.float__)
    , double__ (s.double__)
    , boolean_ (s.boolean_)
    , octet_ (s.octet_)
    , enum__ (s.enum__)
    , string_ (s.string_)
    , longlong_ (s.longlong_)
    , ulonglong_ (s.ulonglong_)
    , longdouble_ (s.longdouble_)
    , element_ (s.element_)
    , member_ (s.member_)
    {
    }

    DataValue&
    DataValue::operator= (DataValue const& s)
    {
      if (&s != this)
      {
        short__ = s.short__;

        long__ = s.long__;

        ushort_ = s.ushort_;

        ulong_ = s.ulong_;

        float__ = s.float__;

        double__ = s.double__;

        boolean_ = s.boolean_;

        octet_ = s.octet_;

        enum__ = s.enum__;

        string_ = s.string_;

        longlong_ = s.longlong_;

        ulonglong_ = s.ulonglong_;

        longdouble_ = s.longdouble_;

        element_ = s.element_;

        member_ = s.member_;
      }

      return *this;
    }


    // DataValue
    DataValue::short_iterator DataValue::
    begin_short ()
    {
      return short__.begin ();
    }

    DataValue::short_iterator DataValue::
    end_short ()
    {
      return short__.end ();
    }

    DataValue::short_const_iterator DataValue::
    begin_short () const
    {
      return short__.begin ();
    }

    DataValue::short_const_iterator DataValue::
    end_short () const
    {
      return short__.end ();
    }

    void DataValue::
    add_short (DataValue::short_value_type const& e)
    {
      short__.push_back (e);
    }

    size_t DataValue::
    count_short(void) const
    {
      return short__.size ();
    }

    // DataValue
    DataValue::long_iterator DataValue::
    begin_long ()
    {
      return long__.begin ();
    }

    DataValue::long_iterator DataValue::
    end_long ()
    {
      return long__.end ();
    }

    DataValue::long_const_iterator DataValue::
    begin_long () const
    {
      return long__.begin ();
    }

    DataValue::long_const_iterator DataValue::
    end_long () const
    {
      return long__.end ();
    }

    void DataValue::
    add_long (DataValue::long_value_type const& e)
    {
      long__.push_back (e);
    }

    size_t DataValue::
    count_long(void) const
    {
      return long__.size ();
    }

    // DataValue
    DataValue::ushort_iterator DataValue::
    begin_ushort ()
    {
      return ushort_.begin ();
    }

    DataValue::ushort_iterator DataValue::
    end_ushort ()
    {
      return ushort_.end ();
    }

    DataValue::ushort_const_iterator DataValue::
    begin_ushort () const
    {
      return ushort_.begin ();
    }

    DataValue::ushort_const_iterator DataValue::
    end_ushort () const
    {
      return ushort_.end ();
    }

    void DataValue::
    add_ushort (DataValue::ushort_value_type const& e)
    {
      ushort_.push_back (e);
    }

    size_t DataValue::
    count_ushort(void) const
    {
      return ushort_.size ();
    }

    // DataValue
    DataValue::ulong_iterator DataValue::
    begin_ulong ()
    {
      return ulong_.begin ();
    }

    DataValue::ulong_iterator DataValue::
    end_ulong ()
    {
      return ulong_.end ();
    }

    DataValue::ulong_const_iterator DataValue::
    begin_ulong () const
    {
      return ulong_.begin ();
    }

    DataValue::ulong_const_iterator DataValue::
    end_ulong () const
    {
      return ulong_.end ();
    }

    void DataValue::
    add_ulong (DataValue::ulong_value_type const& e)
    {
      ulong_.push_back (e);
    }

    size_t DataValue::
    count_ulong(void) const
    {
      return ulong_.size ();
    }

    // DataValue
    DataValue::float_iterator DataValue::
    begin_float ()
    {
      return float__.begin ();
    }

    DataValue::float_iterator DataValue::
    end_float ()
    {
      return float__.end ();
    }

    DataValue::float_const_iterator DataValue::
    begin_float () const
    {
      return float__.begin ();
    }

    DataValue::float_const_iterator DataValue::
    end_float () const
    {
      return float__.end ();
    }

    void DataValue::
    add_float (DataValue::float_value_type const& e)
    {
      float__.push_back (e);
    }

    size_t DataValue::
    count_float(void) const
    {
      return float__.size ();
    }

    // DataValue
    DataValue::double_iterator DataValue::
    begin_double ()
    {
      return double__.begin ();
    }

    DataValue::double_iterator DataValue::
    end_double ()
    {
      return double__.end ();
    }

    DataValue::double_const_iterator DataValue::
    begin_double () const
    {
      return double__.begin ();
    }

    DataValue::double_const_iterator DataValue::
    end_double () const
    {
      return double__.end ();
    }

    void DataValue::
    add_double (DataValue::double_value_type const& e)
    {
      double__.push_back (e);
    }

    size_t DataValue::
    count_double(void) const
    {
      return double__.size ();
    }

    // DataValue
    DataValue::boolean_iterator DataValue::
    begin_boolean ()
    {
      return boolean_.begin ();
    }

    DataValue::boolean_iterator DataValue::
    end_boolean ()
    {
      return boolean_.end ();
    }

    DataValue::boolean_const_iterator DataValue::
    begin_boolean () const
    {
      return boolean_.begin ();
    }

    DataValue::boolean_const_iterator DataValue::
    end_boolean () const
    {
      return boolean_.end ();
    }

    void DataValue::
    add_boolean (DataValue::boolean_value_type const& e)
    {
      boolean_.push_back (e);
    }

    size_t DataValue::
    count_boolean(void) const
    {
      return boolean_.size ();
    }

    // DataValue
    DataValue::octet_iterator DataValue::
    begin_octet ()
    {
      return octet_.begin ();
    }

    DataValue::octet_iterator DataValue::
    end_octet ()
    {
      return octet_.end ();
    }

    DataValue::octet_const_iterator DataValue::
    begin_octet () const
    {
      return octet_.begin ();
    }

    DataValue::octet_const_iterator DataValue::
    end_octet () const
    {
      return octet_.end ();
    }

    void DataValue::
    add_octet (DataValue::octet_value_type const& e)
    {
      octet_.push_back (e);
    }

    size_t DataValue::
    count_octet(void) const
    {
      return octet_.size ();
    }

    // DataValue
    DataValue::enum_iterator DataValue::
    begin_enum ()
    {
      return enum__.begin ();
    }

    DataValue::enum_iterator DataValue::
    end_enum ()
    {
      return enum__.end ();
    }

    DataValue::enum_const_iterator DataValue::
    begin_enum () const
    {
      return enum__.begin ();
    }

    DataValue::enum_const_iterator DataValue::
    end_enum () const
    {
      return enum__.end ();
    }

    void DataValue::
    add_enum (DataValue::enum_value_type const& e)
    {
      enum__.push_back (e);
    }

    size_t DataValue::
    count_enum(void) const
    {
      return enum__.size ();
    }

    // DataValue
    DataValue::string_iterator DataValue::
    begin_string ()
    {
      return string_.begin ();
    }

    DataValue::string_iterator DataValue::
    end_string ()
    {
      return string_.end ();
    }

    DataValue::string_const_iterator DataValue::
    begin_string () const
    {
      return string_.begin ();
    }

    DataValue::string_const_iterator DataValue::
    end_string () const
    {
      return string_.end ();
    }

    void DataValue::
    add_string (DataValue::string_value_type const& e)
    {
      string_.push_back (e);
    }

    size_t DataValue::
    count_string(void) const
    {
      return string_.size ();
    }

    // DataValue
    DataValue::longlong_iterator DataValue::
    begin_longlong ()
    {
      return longlong_.begin ();
    }

    DataValue::longlong_iterator DataValue::
    end_longlong ()
    {
      return longlong_.end ();
    }

    DataValue::longlong_const_iterator DataValue::
    begin_longlong () const
    {
      return longlong_.begin ();
    }

    DataValue::longlong_const_iterator DataValue::
    end_longlong () const
    {
      return longlong_.end ();
    }

    void DataValue::
    add_longlong (DataValue::longlong_value_type const& e)
    {
      longlong_.push_back (e);
    }

    size_t DataValue::
    count_longlong(void) const
    {
      return longlong_.size ();
    }

    // DataValue
    DataValue::ulonglong_iterator DataValue::
    begin_ulonglong ()
    {
      return ulonglong_.begin ();
    }

    DataValue::ulonglong_iterator DataValue::
    end_ulonglong ()
    {
      return ulonglong_.end ();
    }

    DataValue::ulonglong_const_iterator DataValue::
    begin_ulonglong () const
    {
      return ulonglong_.begin ();
    }

    DataValue::ulonglong_const_iterator DataValue::
    end_ulonglong () const
    {
      return ulonglong_.end ();
    }

    void DataValue::
    add_ulonglong (DataValue::ulonglong_value_type const& e)
    {
      ulonglong_.push_back (e);
    }

    size_t DataValue::
    count_ulonglong(void) const
    {
      return ulonglong_.size ();
    }

    // DataValue
    DataValue::longdouble_iterator DataValue::
    begin_longdouble ()
    {
      return longdouble_.begin ();
    }

    DataValue::longdouble_iterator DataValue::
    end_longdouble ()
    {
      return longdouble_.end ();
    }

    DataValue::longdouble_const_iterator DataValue::
    begin_longdouble () const
    {
      return longdouble_.begin ();
    }

    DataValue::longdouble_const_iterator DataValue::
    end_longdouble () const
    {
      return longdouble_.end ();
    }

    void DataValue::
    add_longdouble (DataValue::longdouble_value_type const& e)
    {
      longdouble_.push_back (e);
    }

    size_t DataValue::
    count_longdouble(void) const
    {
      return longdouble_.size ();
    }

    // DataValue
    DataValue::element_iterator DataValue::
    begin_element ()
    {
      return element_.begin ();
    }

    DataValue::element_iterator DataValue::
    end_element ()
    {
      return element_.end ();
    }

    DataValue::element_const_iterator DataValue::
    begin_element () const
    {
      return element_.begin ();
    }

    DataValue::element_const_iterator DataValue::
    end_element () const
    {
      return element_.end ();
    }

    void DataValue::
    add_element (DataValue::element_value_type const& e)
    {
      element_.push_back (e);
    }

    size_t DataValue::
    count_element(void) const
    {
      return element_.size ();
    }

    // DataValue
    DataValue::member_iterator DataValue::
    begin_member ()
    {
      return member_.begin ();
    }

    DataValue::member_iterator DataValue::
    end_member ()
    {
      return member_.end ();
    }

    DataValue::member_const_iterator DataValue::
    begin_member () const
    {
      return member_.begin ();
    }

    DataValue::member_const_iterator DataValue::
    end_member () const
    {
      return member_.end ();
    }

    void DataValue::
    add_member (DataValue::member_value_type const& e)
    {
      member_.push_back (e);
    }

    size_t DataValue::
    count_member(void) const
    {
      return member_.size ();
    }


    // AliasType

    AliasType::AliasType (::XMLSchema::string<ACE_TCHAR> const& name__,
                          ::XMLSchema::string<ACE_TCHAR> const& typeId__,
                          ::DAnCE::Config_Handlers::DataType const& elementType__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , typeId_ (new ::XMLSchema::string<ACE_TCHAR> (typeId__))
    , elementType_ (new ::DAnCE::Config_Handlers::DataType (elementType__))
    {
      name_->container (this);
      typeId_->container (this);
      elementType_->container (this);
    }

    AliasType::AliasType (AliasType const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , typeId_ (new ::XMLSchema::string<ACE_TCHAR> (*s.typeId_))
    , elementType_ (new ::DAnCE::Config_Handlers::DataType (*s.elementType_))
    {
      name_->container (this);
      typeId_->container (this);
      elementType_->container (this);
    }

    AliasType&
    AliasType::operator= (AliasType const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        typeId (*s.typeId_);

        elementType (*s.elementType_);
      }

      return *this;
    }


    // AliasType
    ::XMLSchema::string<ACE_TCHAR> const& AliasType::
    name () const
    {
      return *name_;
    }

    void AliasType::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // AliasType
    ::XMLSchema::string<ACE_TCHAR> const& AliasType::
    typeId () const
    {
      return *typeId_;
    }

    void AliasType::
    typeId (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *typeId_ = e;
    }

    // AliasType
    ::DAnCE::Config_Handlers::DataType const& AliasType::
    elementType () const
    {
      return *elementType_;
    }

    void AliasType::
    elementType (::DAnCE::Config_Handlers::DataType const& e)
    {
      *elementType_ = e;
    }


    // EnumType

    EnumType::EnumType (::XMLSchema::string<ACE_TCHAR> const& name__,
                        ::XMLSchema::string<ACE_TCHAR> const& typeId__,
                        member_container_type const& member__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , typeId_ (new ::XMLSchema::string<ACE_TCHAR> (typeId__))
    , member_ (member__)
    {
      name_->container (this);
      typeId_->container (this);
    }

    EnumType::EnumType (EnumType const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , typeId_ (new ::XMLSchema::string<ACE_TCHAR> (*s.typeId_))
    , member_ (s.member_)
    {
      name_->container (this);
      typeId_->container (this);
    }

    EnumType&
    EnumType::operator= (EnumType const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        typeId (*s.typeId_);

        member_ = s.member_;
      }

      return *this;
    }


    // EnumType
    ::XMLSchema::string<ACE_TCHAR> const& EnumType::
    name () const
    {
      return *name_;
    }

    void EnumType::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // EnumType
    ::XMLSchema::string<ACE_TCHAR> const& EnumType::
    typeId () const
    {
      return *typeId_;
    }

    void EnumType::
    typeId (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *typeId_ = e;
    }

    // EnumType
    EnumType::member_iterator EnumType::
    begin_member ()
    {
      return member_.begin ();
    }

    EnumType::member_iterator EnumType::
    end_member ()
    {
      return member_.end ();
    }

    EnumType::member_const_iterator EnumType::
    begin_member () const
    {
      return member_.begin ();
    }

    EnumType::member_const_iterator EnumType::
    end_member () const
    {
      return member_.end ();
    }

    void EnumType::
    add_member (EnumType::member_value_type const& e)
    {
      member_.push_back (e);
    }

    size_t EnumType::
    count_member(void) const
    {
      return member_.size ();
    }


    // BoundedStringType

    BoundedStringType::BoundedStringType ()
    : ::XSCRT::Type ()
    {
    }

    BoundedStringType::BoundedStringType (BoundedStringType const& s) :
    ::XSCRT::Type (s)
    , bound_ (s.bound_)
    {
    }

    BoundedStringType&
    BoundedStringType::operator= (BoundedStringType const& s)
    {
      if (&s != this)
      {
        bound_ = s.bound_;
      }

      return *this;
    }


    // BoundedStringType
    BoundedStringType::bound_iterator BoundedStringType::
    begin_bound ()
    {
      return bound_.begin ();
    }

    BoundedStringType::bound_iterator BoundedStringType::
    end_bound ()
    {
      return bound_.end ();
    }

    BoundedStringType::bound_const_iterator BoundedStringType::
    begin_bound () const
    {
      return bound_.begin ();
    }

    BoundedStringType::bound_const_iterator BoundedStringType::
    end_bound () const
    {
      return bound_.end ();
    }

    void BoundedStringType::
    add_bound (BoundedStringType::bound_value_type const& e)
    {
      bound_.push_back (e);
    }

    size_t BoundedStringType::
    count_bound(void) const
    {
      return bound_.size ();
    }


    // StructType

    StructType::StructType (::XMLSchema::string<ACE_TCHAR> const& name__,
                            ::XMLSchema::string<ACE_TCHAR> const& typeId__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , typeId_ (new ::XMLSchema::string<ACE_TCHAR> (typeId__))
    {
      name_->container (this);
      typeId_->container (this);
    }

    StructType::StructType (StructType const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , typeId_ (new ::XMLSchema::string<ACE_TCHAR> (*s.typeId_))
    , member_ (s.member_)
    {
      name_->container (this);
      typeId_->container (this);
    }

    StructType&
    StructType::operator= (StructType const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        typeId (*s.typeId_);

        member_ = s.member_;
      }

      return *this;
    }


    // StructType
    ::XMLSchema::string<ACE_TCHAR> const& StructType::
    name () const
    {
      return *name_;
    }

    void StructType::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // StructType
    ::XMLSchema::string<ACE_TCHAR> const& StructType::
    typeId () const
    {
      return *typeId_;
    }

    void StructType::
    typeId (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *typeId_ = e;
    }

    // StructType
    StructType::member_iterator StructType::
    begin_member ()
    {
      return member_.begin ();
    }

    StructType::member_iterator StructType::
    end_member ()
    {
      return member_.end ();
    }

    StructType::member_const_iterator StructType::
    begin_member () const
    {
      return member_.begin ();
    }

    StructType::member_const_iterator StructType::
    end_member () const
    {
      return member_.end ();
    }

    void StructType::
    add_member (StructType::member_value_type const& e)
    {
      member_.push_back (e);
    }

    size_t StructType::
    count_member(void) const
    {
      return member_.size ();
    }


    // StructMemberType

    StructMemberType::StructMemberType (::XMLSchema::string<ACE_TCHAR> const& name__,
                                        ::DAnCE::Config_Handlers::DataType const& type__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , type_ (new ::DAnCE::Config_Handlers::DataType (type__))
    {
      name_->container (this);
      type_->container (this);
    }

    StructMemberType::StructMemberType (StructMemberType const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , type_ (new ::DAnCE::Config_Handlers::DataType (*s.type_))
    {
      name_->container (this);
      type_->container (this);
    }

    StructMemberType&
    StructMemberType::operator= (StructMemberType const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        type (*s.type_);
      }

      return *this;
    }


    // StructMemberType
    ::XMLSchema::string<ACE_TCHAR> const& StructMemberType::
    name () const
    {
      return *name_;
    }

    void StructMemberType::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // StructMemberType
    ::DAnCE::Config_Handlers::DataType const& StructMemberType::
    type () const
    {
      return *type_;
    }

    void StructMemberType::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }


    // ValueType

    ValueType::ValueType (::XMLSchema::string<ACE_TCHAR> const& name__,
                          ::XMLSchema::string<ACE_TCHAR> const& typeId__,
                          ::XMLSchema::string<ACE_TCHAR> const& modifier__,
                          ::DAnCE::Config_Handlers::DataType const& baseType__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , typeId_ (new ::XMLSchema::string<ACE_TCHAR> (typeId__))
    , modifier_ (new ::XMLSchema::string<ACE_TCHAR> (modifier__))
    , baseType_ (new ::DAnCE::Config_Handlers::DataType (baseType__))
    {
      name_->container (this);
      typeId_->container (this);
      modifier_->container (this);
      baseType_->container (this);
    }

    ValueType::ValueType (ValueType const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , typeId_ (new ::XMLSchema::string<ACE_TCHAR> (*s.typeId_))
    , modifier_ (new ::XMLSchema::string<ACE_TCHAR> (*s.modifier_))
    , baseType_ (new ::DAnCE::Config_Handlers::DataType (*s.baseType_))
    , member_ (s.member_)
    {
      name_->container (this);
      typeId_->container (this);
      modifier_->container (this);
      baseType_->container (this);
    }

    ValueType&
    ValueType::operator= (ValueType const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        typeId (*s.typeId_);

        modifier (*s.modifier_);

        baseType (*s.baseType_);

        member_ = s.member_;
      }

      return *this;
    }


    // ValueType
    ::XMLSchema::string<ACE_TCHAR> const& ValueType::
    name () const
    {
      return *name_;
    }

    void ValueType::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // ValueType
    ::XMLSchema::string<ACE_TCHAR> const& ValueType::
    typeId () const
    {
      return *typeId_;
    }

    void ValueType::
    typeId (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *typeId_ = e;
    }

    // ValueType
    ::XMLSchema::string<ACE_TCHAR> const& ValueType::
    modifier () const
    {
      return *modifier_;
    }

    void ValueType::
    modifier (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *modifier_ = e;
    }

    // ValueType
    ::DAnCE::Config_Handlers::DataType const& ValueType::
    baseType () const
    {
      return *baseType_;
    }

    void ValueType::
    baseType (::DAnCE::Config_Handlers::DataType const& e)
    {
      *baseType_ = e;
    }

    // ValueType
    ValueType::member_iterator ValueType::
    begin_member ()
    {
      return member_.begin ();
    }

    ValueType::member_iterator ValueType::
    end_member ()
    {
      return member_.end ();
    }

    ValueType::member_const_iterator ValueType::
    begin_member () const
    {
      return member_.begin ();
    }

    ValueType::member_const_iterator ValueType::
    end_member () const
    {
      return member_.end ();
    }

    void ValueType::
    add_member (ValueType::member_value_type const& e)
    {
      member_.push_back (e);
    }

    size_t ValueType::
    count_member(void) const
    {
      return member_.size ();
    }


    // ValueMemberType

    ValueMemberType::ValueMemberType (::XMLSchema::string<ACE_TCHAR> const& name__,
                                      ::XMLSchema::string<ACE_TCHAR> const& visibility__,
                                      ::DAnCE::Config_Handlers::DataType const& type__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , visibility_ (new ::XMLSchema::string<ACE_TCHAR> (visibility__))
    , type_ (new ::DAnCE::Config_Handlers::DataType (type__))
    {
      name_->container (this);
      visibility_->container (this);
      type_->container (this);
    }

    ValueMemberType::ValueMemberType (ValueMemberType const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , visibility_ (new ::XMLSchema::string<ACE_TCHAR> (*s.visibility_))
    , type_ (new ::DAnCE::Config_Handlers::DataType (*s.type_))
    {
      name_->container (this);
      visibility_->container (this);
      type_->container (this);
    }

    ValueMemberType&
    ValueMemberType::operator= (ValueMemberType const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        visibility (*s.visibility_);

        type (*s.type_);
      }

      return *this;
    }


    // ValueMemberType
    ::XMLSchema::string<ACE_TCHAR> const& ValueMemberType::
    name () const
    {
      return *name_;
    }

    void ValueMemberType::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // ValueMemberType
    ::XMLSchema::string<ACE_TCHAR> const& ValueMemberType::
    visibility () const
    {
      return *visibility_;
    }

    void ValueMemberType::
    visibility (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *visibility_ = e;
    }

    // ValueMemberType
    ::DAnCE::Config_Handlers::DataType const& ValueMemberType::
    type () const
    {
      return *type_;
    }

    void ValueMemberType::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }


    // NamedValue

    NamedValue::NamedValue (::XMLSchema::string<ACE_TCHAR> const& name__,
                            ::DAnCE::Config_Handlers::DataValue const& value__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , value_ (new ::DAnCE::Config_Handlers::DataValue (value__))
    {
      name_->container (this);
      value_->container (this);
    }

    NamedValue::NamedValue (NamedValue const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , value_ (new ::DAnCE::Config_Handlers::DataValue (*s.value_))
    {
      name_->container (this);
      value_->container (this);
    }

    NamedValue&
    NamedValue::operator= (NamedValue const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        value (*s.value_);
      }

      return *this;
    }


    // NamedValue
    ::XMLSchema::string<ACE_TCHAR> const& NamedValue::
    name () const
    {
      return *name_;
    }

    void NamedValue::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // NamedValue
    ::DAnCE::Config_Handlers::DataValue const& NamedValue::
    value () const
    {
      return *value_;
    }

    void NamedValue::
    value (::DAnCE::Config_Handlers::DataValue const& e)
    {
      *value_ = e;
    }


    // ArrayType

    ArrayType::ArrayType (::XMLSchema::unsignedInt const& length__,
                          ::DAnCE::Config_Handlers::DataType const& elementType__)
    : ::XSCRT::Type ()
    , length_ (new ::XMLSchema::unsignedInt (length__))
    , elementType_ (new ::DAnCE::Config_Handlers::DataType (elementType__))
    {
      length_->container (this);
      elementType_->container (this);
    }

    ArrayType::ArrayType (ArrayType const& s) :
    ::XSCRT::Type (s)
    , length_ (new ::XMLSchema::unsignedInt (*s.length_))
    , elementType_ (new ::DAnCE::Config_Handlers::DataType (*s.elementType_))
    {
      length_->container (this);
      elementType_->container (this);
    }

    ArrayType&
    ArrayType::operator= (ArrayType const& s)
    {
      if (&s != this)
      {
        length (*s.length_);

        elementType (*s.elementType_);
      }

      return *this;
    }


    // ArrayType
    ::XMLSchema::unsignedInt const& ArrayType::
    length () const
    {
      return *length_;
    }

    void ArrayType::
    length (::XMLSchema::unsignedInt const& e)
    {
      *length_ = e;
    }

    // ArrayType
    ::DAnCE::Config_Handlers::DataType const& ArrayType::
    elementType () const
    {
      return *elementType_;
    }

    void ArrayType::
    elementType (::DAnCE::Config_Handlers::DataType const& e)
    {
      *elementType_ = e;
    }


    // SequenceType

    SequenceType::SequenceType (::DAnCE::Config_Handlers::DataType const& elementType__)
    : ::XSCRT::Type ()
    , elementType_ (new ::DAnCE::Config_Handlers::DataType (elementType__))
    {
      elementType_->container (this);
    }

    SequenceType::SequenceType (SequenceType const& s) :
    ::XSCRT::Type (s)
    , bound_ (s.bound_.get () ? new ::XMLSchema::unsignedInt (*s.bound_) : 0)
    , elementType_ (new ::DAnCE::Config_Handlers::DataType (*s.elementType_))
    {
      if (bound_.get ()) bound_->container (this);
      elementType_->container (this);
    }

    SequenceType&
    SequenceType::operator= (SequenceType const& s)
    {
      if (&s != this)
      {
        if (s.bound_.get ())
          bound (*(s.bound_));
        else
          bound_.reset (0);

        elementType (*s.elementType_);
      }

      return *this;
    }


    // SequenceType
    bool SequenceType::
    bound_p () const
    {
      return bound_.get () != 0;
    }

    ::XMLSchema::unsignedInt const& SequenceType::
    bound () const
    {
      return *bound_;
    }

    void SequenceType::
    bound (::XMLSchema::unsignedInt const& e)
    {
      if (bound_.get ())
      {
        *bound_ = e;
      }

      else
      {
        bound_ = SequenceType::bound_auto_ptr_type (new ::XMLSchema::unsignedInt (e));
        bound_->container (this);
      }
    }

    // SequenceType
    ::DAnCE::Config_Handlers::DataType const& SequenceType::
    elementType () const
    {
      return *elementType_;
    }

    void SequenceType::
    elementType (::DAnCE::Config_Handlers::DataType const& e)
    {
      *elementType_ = e;
    }


    // Any

    Any::Any (::DAnCE::Config_Handlers::DataType const& type__,
              ::DAnCE::Config_Handlers::DataValue const& value__)
    : ::XSCRT::Type ()
    , type_ (new ::DAnCE::Config_Handlers::DataType (type__))
    , value_ (new ::DAnCE::Config_Handlers::DataValue (value__))
    {
      type_->container (this);
      value_->container (this);
    }

    Any::Any (Any const& s) :
    ::XSCRT::Type (s)
    , type_ (new ::DAnCE::Config_Handlers::DataType (*s.type_))
    , value_ (new ::DAnCE::Config_Handlers::DataValue (*s.value_))
    {
      type_->container (this);
      value_->container (this);
    }

    Any&
    Any::operator= (Any const& s)
    {
      if (&s != this)
      {
        type (*s.type_);

        value (*s.value_);
      }

      return *this;
    }


    // Any
    ::DAnCE::Config_Handlers::DataType const& Any::
    type () const
    {
      return *type_;
    }

    void Any::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }

    // Any
    ::DAnCE::Config_Handlers::DataValue const& Any::
    value () const
    {
      return *value_;
    }

    void Any::
    value (::DAnCE::Config_Handlers::DataValue const& e)
    {
      *value_ = e;
    }


    // Property

    Property::Property (::XMLSchema::string<ACE_TCHAR> const& name__,
                        ::DAnCE::Config_Handlers::Any const& value__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , value_ (new ::DAnCE::Config_Handlers::Any (value__))
    {
      name_->container (this);
      value_->container (this);
    }

    Property::Property (Property const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , value_ (new ::DAnCE::Config_Handlers::Any (*s.value_))
    {
      name_->container (this);
      value_->container (this);
    }

    Property&
    Property::operator= (Property const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        value (*s.value_);
      }

      return *this;
    }


    // Property
    ::XMLSchema::string<ACE_TCHAR> const& Property::
    name () const
    {
      return *name_;
    }

    void Property::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // Property
    ::DAnCE::Config_Handlers::Any const& Property::
    value () const
    {
      return *value_;
    }

    void Property::
    value (::DAnCE::Config_Handlers::Any const& e)
    {
      *value_ = e;
    }


    // SatisfierPropertyKind

    SatisfierPropertyKind::Value SatisfierPropertyKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::SatisfierPropertyKind const& a, ::DAnCE::Config_Handlers::SatisfierPropertyKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::SatisfierPropertyKind const& a, ::DAnCE::Config_Handlers::SatisfierPropertyKind const& b)
    {
      return a.v_ != b.v_;
    }

    SatisfierPropertyKind::
    SatisfierPropertyKind (SatisfierPropertyKind::Value v)
    : v_ (v)
    {
    }

    // SatisfierProperty

    SatisfierProperty::SatisfierProperty (::XMLSchema::string<ACE_TCHAR> const& name__,
                                          ::DAnCE::Config_Handlers::SatisfierPropertyKind const& kind__,
                                          ::XMLSchema::boolean const& dynamic__,
                                          ::DAnCE::Config_Handlers::Any const& value__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , kind_ (new ::DAnCE::Config_Handlers::SatisfierPropertyKind (kind__))
    , dynamic_ (new ::XMLSchema::boolean (dynamic__))
    , value_ (new ::DAnCE::Config_Handlers::Any (value__))
    {
      name_->container (this);
      kind_->container (this);
      dynamic_->container (this);
      value_->container (this);
    }

    SatisfierProperty::SatisfierProperty (SatisfierProperty const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , kind_ (new ::DAnCE::Config_Handlers::SatisfierPropertyKind (*s.kind_))
    , dynamic_ (new ::XMLSchema::boolean (*s.dynamic_))
    , value_ (new ::DAnCE::Config_Handlers::Any (*s.value_))
    {
      name_->container (this);
      kind_->container (this);
      dynamic_->container (this);
      value_->container (this);
    }

    SatisfierProperty&
    SatisfierProperty::operator= (SatisfierProperty const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        kind (*s.kind_);

        dynamic (*s.dynamic_);

        value (*s.value_);
      }

      return *this;
    }


    // SatisfierProperty
    ::XMLSchema::string<ACE_TCHAR> const& SatisfierProperty::
    name () const
    {
      return *name_;
    }

    void SatisfierProperty::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // SatisfierProperty
    ::DAnCE::Config_Handlers::SatisfierPropertyKind const& SatisfierProperty::
    kind () const
    {
      return *kind_;
    }

    void SatisfierProperty::
    kind (::DAnCE::Config_Handlers::SatisfierPropertyKind const& e)
    {
      *kind_ = e;
    }

    // SatisfierProperty
    ::XMLSchema::boolean const& SatisfierProperty::
    dynamic () const
    {
      return *dynamic_;
    }

    void SatisfierProperty::
    dynamic (::XMLSchema::boolean const& e)
    {
      *dynamic_ = e;
    }

    // SatisfierProperty
    ::DAnCE::Config_Handlers::Any const& SatisfierProperty::
    value () const
    {
      return *value_;
    }

    void SatisfierProperty::
    value (::DAnCE::Config_Handlers::Any const& e)
    {
      *value_ = e;
    }


    // Resource

    Resource::Resource (::XMLSchema::string<ACE_TCHAR> const& name__,
                        resourceType_container_type const& resourceType__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , resourceType_ (resourceType__)
    {
      name_->container (this);
    }

    Resource::Resource (Resource const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , resourceType_ (s.resourceType_)
    , property_ (s.property_)
    {
      name_->container (this);
    }

    Resource&
    Resource::operator= (Resource const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        resourceType_ = s.resourceType_;

        property_ = s.property_;
      }

      return *this;
    }


    // Resource
    ::XMLSchema::string<ACE_TCHAR> const& Resource::
    name () const
    {
      return *name_;
    }

    void Resource::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // Resource
    Resource::resourceType_iterator Resource::
    begin_resourceType ()
    {
      return resourceType_.begin ();
    }

    Resource::resourceType_iterator Resource::
    end_resourceType ()
    {
      return resourceType_.end ();
    }

    Resource::resourceType_const_iterator Resource::
    begin_resourceType () const
    {
      return resourceType_.begin ();
    }

    Resource::resourceType_const_iterator Resource::
    end_resourceType () const
    {
      return resourceType_.end ();
    }

    void Resource::
    add_resourceType (Resource::resourceType_value_type const& e)
    {
      resourceType_.push_back (e);
    }

    size_t Resource::
    count_resourceType(void) const
    {
      return resourceType_.size ();
    }

    // Resource
    Resource::property_iterator Resource::
    begin_property ()
    {
      return property_.begin ();
    }

    Resource::property_iterator Resource::
    end_property ()
    {
      return property_.end ();
    }

    Resource::property_const_iterator Resource::
    begin_property () const
    {
      return property_.begin ();
    }

    Resource::property_const_iterator Resource::
    end_property () const
    {
      return property_.end ();
    }

    void Resource::
    add_property (Resource::property_value_type const& e)
    {
      property_.push_back (e);
    }

    size_t Resource::
    count_property(void) const
    {
      return property_.size ();
    }


    // Requirement

    Requirement::Requirement (::XMLSchema::string<ACE_TCHAR> const& name__,
                              ::XMLSchema::string<ACE_TCHAR> const& resourceType__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , resourceType_ (new ::XMLSchema::string<ACE_TCHAR> (resourceType__))
    {
      name_->container (this);
      resourceType_->container (this);
    }

    Requirement::Requirement (Requirement const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , resourceType_ (new ::XMLSchema::string<ACE_TCHAR> (*s.resourceType_))
    , property_ (s.property_)
    {
      name_->container (this);
      resourceType_->container (this);
    }

    Requirement&
    Requirement::operator= (Requirement const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        resourceType (*s.resourceType_);

        property_ = s.property_;
      }

      return *this;
    }


    // Requirement
    ::XMLSchema::string<ACE_TCHAR> const& Requirement::
    name () const
    {
      return *name_;
    }

    void Requirement::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // Requirement
    ::XMLSchema::string<ACE_TCHAR> const& Requirement::
    resourceType () const
    {
      return *resourceType_;
    }

    void Requirement::
    resourceType (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *resourceType_ = e;
    }

    // Requirement
    Requirement::property_iterator Requirement::
    begin_property ()
    {
      return property_.begin ();
    }

    Requirement::property_iterator Requirement::
    end_property ()
    {
      return property_.end ();
    }

    Requirement::property_const_iterator Requirement::
    begin_property () const
    {
      return property_.begin ();
    }

    Requirement::property_const_iterator Requirement::
    end_property () const
    {
      return property_.end ();
    }

    void Requirement::
    add_property (Requirement::property_value_type const& e)
    {
      property_.push_back (e);
    }

    size_t Requirement::
    count_property(void) const
    {
      return property_.size ();
    }


    // ResourceDeploymentDescription

    ResourceDeploymentDescription::ResourceDeploymentDescription (::XMLSchema::string<ACE_TCHAR> const& requirementName__,
                                                                  ::XMLSchema::string<ACE_TCHAR> const& resourceName__)
    : ::XSCRT::Type ()
    , requirementName_ (new ::XMLSchema::string<ACE_TCHAR> (requirementName__))
    , resourceName_ (new ::XMLSchema::string<ACE_TCHAR> (resourceName__))
    {
      requirementName_->container (this);
      resourceName_->container (this);
    }

    ResourceDeploymentDescription::ResourceDeploymentDescription (ResourceDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , requirementName_ (new ::XMLSchema::string<ACE_TCHAR> (*s.requirementName_))
    , resourceName_ (new ::XMLSchema::string<ACE_TCHAR> (*s.resourceName_))
    , property_ (s.property_)
    {
      requirementName_->container (this);
      resourceName_->container (this);
    }

    ResourceDeploymentDescription&
    ResourceDeploymentDescription::operator= (ResourceDeploymentDescription const& s)
    {
      if (&s != this)
      {
        requirementName (*s.requirementName_);

        resourceName (*s.resourceName_);

        property_ = s.property_;
      }

      return *this;
    }


    // ResourceDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& ResourceDeploymentDescription::
    requirementName () const
    {
      return *requirementName_;
    }

    void ResourceDeploymentDescription::
    requirementName (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *requirementName_ = e;
    }

    // ResourceDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& ResourceDeploymentDescription::
    resourceName () const
    {
      return *resourceName_;
    }

    void ResourceDeploymentDescription::
    resourceName (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *resourceName_ = e;
    }

    // ResourceDeploymentDescription
    ResourceDeploymentDescription::property_iterator ResourceDeploymentDescription::
    begin_property ()
    {
      return property_.begin ();
    }

    ResourceDeploymentDescription::property_iterator ResourceDeploymentDescription::
    end_property ()
    {
      return property_.end ();
    }

    ResourceDeploymentDescription::property_const_iterator ResourceDeploymentDescription::
    begin_property () const
    {
      return property_.begin ();
    }

    ResourceDeploymentDescription::property_const_iterator ResourceDeploymentDescription::
    end_property () const
    {
      return property_.end ();
    }

    void ResourceDeploymentDescription::
    add_property (ResourceDeploymentDescription::property_value_type const& e)
    {
      property_.push_back (e);
    }

    size_t ResourceDeploymentDescription::
    count_property(void) const
    {
      return property_.size ();
    }


    // ArtifactDeploymentDescription

    ArtifactDeploymentDescription::ArtifactDeploymentDescription (::XMLSchema::string<ACE_TCHAR> const& name__,
                                                                  ::XMLSchema::string<ACE_TCHAR> const& node__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , node_ (new ::XMLSchema::string<ACE_TCHAR> (node__))
    {
      name_->container (this);
      node_->container (this);
    }

    ArtifactDeploymentDescription::ArtifactDeploymentDescription (ArtifactDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , source_ (s.source_)
    , node_ (new ::XMLSchema::string<ACE_TCHAR> (*s.node_))
    , location_ (s.location_)
    , execParameter_ (s.execParameter_)
    , deployRequirement_ (s.deployRequirement_)
    , deployedResource_ (s.deployedResource_)
    , id_ (s.id_.get () ? new ::XMLSchema::ID<ACE_TCHAR> (*s.id_) : 0)
    {
      name_->container (this);
      node_->container (this);
      if (id_.get ()) id_->container (this);
    }

    ArtifactDeploymentDescription&
    ArtifactDeploymentDescription::operator= (ArtifactDeploymentDescription const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        source_ = s.source_;

        node (*s.node_);

        location_ = s.location_;

        execParameter_ = s.execParameter_;

        deployRequirement_ = s.deployRequirement_;

        deployedResource_ = s.deployedResource_;

        if (s.id_.get ()) id (*(s.id_));
        else id_.reset (0);
      }

      return *this;
    }


    // ArtifactDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& ArtifactDeploymentDescription::
    name () const
    {
      return *name_;
    }

    void ArtifactDeploymentDescription::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // ArtifactDeploymentDescription
    ArtifactDeploymentDescription::source_iterator ArtifactDeploymentDescription::
    begin_source ()
    {
      return source_.begin ();
    }

    ArtifactDeploymentDescription::source_iterator ArtifactDeploymentDescription::
    end_source ()
    {
      return source_.end ();
    }

    ArtifactDeploymentDescription::source_const_iterator ArtifactDeploymentDescription::
    begin_source () const
    {
      return source_.begin ();
    }

    ArtifactDeploymentDescription::source_const_iterator ArtifactDeploymentDescription::
    end_source () const
    {
      return source_.end ();
    }

    void ArtifactDeploymentDescription::
    add_source (ArtifactDeploymentDescription::source_value_type const& e)
    {
      source_.push_back (e);
    }

    size_t ArtifactDeploymentDescription::
    count_source(void) const
    {
      return source_.size ();
    }

    // ArtifactDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& ArtifactDeploymentDescription::
    node () const
    {
      return *node_;
    }

    void ArtifactDeploymentDescription::
    node (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *node_ = e;
    }

    // ArtifactDeploymentDescription
    ArtifactDeploymentDescription::location_iterator ArtifactDeploymentDescription::
    begin_location ()
    {
      return location_.begin ();
    }

    ArtifactDeploymentDescription::location_iterator ArtifactDeploymentDescription::
    end_location ()
    {
      return location_.end ();
    }

    ArtifactDeploymentDescription::location_const_iterator ArtifactDeploymentDescription::
    begin_location () const
    {
      return location_.begin ();
    }

    ArtifactDeploymentDescription::location_const_iterator ArtifactDeploymentDescription::
    end_location () const
    {
      return location_.end ();
    }

    void ArtifactDeploymentDescription::
    add_location (ArtifactDeploymentDescription::location_value_type const& e)
    {
      location_.push_back (e);
    }

    size_t ArtifactDeploymentDescription::
    count_location(void) const
    {
      return location_.size ();
    }

    // ArtifactDeploymentDescription
    ArtifactDeploymentDescription::execParameter_iterator ArtifactDeploymentDescription::
    begin_execParameter ()
    {
      return execParameter_.begin ();
    }

    ArtifactDeploymentDescription::execParameter_iterator ArtifactDeploymentDescription::
    end_execParameter ()
    {
      return execParameter_.end ();
    }

    ArtifactDeploymentDescription::execParameter_const_iterator ArtifactDeploymentDescription::
    begin_execParameter () const
    {
      return execParameter_.begin ();
    }

    ArtifactDeploymentDescription::execParameter_const_iterator ArtifactDeploymentDescription::
    end_execParameter () const
    {
      return execParameter_.end ();
    }

    void ArtifactDeploymentDescription::
    add_execParameter (ArtifactDeploymentDescription::execParameter_value_type const& e)
    {
      execParameter_.push_back (e);
    }

    size_t ArtifactDeploymentDescription::
    count_execParameter(void) const
    {
      return execParameter_.size ();
    }

    // ArtifactDeploymentDescription
    ArtifactDeploymentDescription::deployRequirement_iterator ArtifactDeploymentDescription::
    begin_deployRequirement ()
    {
      return deployRequirement_.begin ();
    }

    ArtifactDeploymentDescription::deployRequirement_iterator ArtifactDeploymentDescription::
    end_deployRequirement ()
    {
      return deployRequirement_.end ();
    }

    ArtifactDeploymentDescription::deployRequirement_const_iterator ArtifactDeploymentDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.begin ();
    }

    ArtifactDeploymentDescription::deployRequirement_const_iterator ArtifactDeploymentDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.end ();
    }

    void ArtifactDeploymentDescription::
    add_deployRequirement (ArtifactDeploymentDescription::deployRequirement_value_type const& e)
    {
      deployRequirement_.push_back (e);
    }

    size_t ArtifactDeploymentDescription::
    count_deployRequirement(void) const
    {
      return deployRequirement_.size ();
    }

    // ArtifactDeploymentDescription
    ArtifactDeploymentDescription::deployedResource_iterator ArtifactDeploymentDescription::
    begin_deployedResource ()
    {
      return deployedResource_.begin ();
    }

    ArtifactDeploymentDescription::deployedResource_iterator ArtifactDeploymentDescription::
    end_deployedResource ()
    {
      return deployedResource_.end ();
    }

    ArtifactDeploymentDescription::deployedResource_const_iterator ArtifactDeploymentDescription::
    begin_deployedResource () const
    {
      return deployedResource_.begin ();
    }

    ArtifactDeploymentDescription::deployedResource_const_iterator ArtifactDeploymentDescription::
    end_deployedResource () const
    {
      return deployedResource_.end ();
    }

    void ArtifactDeploymentDescription::
    add_deployedResource (ArtifactDeploymentDescription::deployedResource_value_type const& e)
    {
      deployedResource_.push_back (e);
    }

    size_t ArtifactDeploymentDescription::
    count_deployedResource(void) const
    {
      return deployedResource_.size ();
    }

    // ArtifactDeploymentDescription
    bool ArtifactDeploymentDescription::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID<ACE_TCHAR> const& ArtifactDeploymentDescription::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID<ACE_TCHAR>& ArtifactDeploymentDescription::
    id ()
    {
      return *id_;
    }

    void ArtifactDeploymentDescription::
    id (::XMLSchema::ID<ACE_TCHAR> const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ArtifactDeploymentDescription::id_auto_ptr_type (new ::XMLSchema::ID<ACE_TCHAR> (e));
        id_->container (this);
      }
    }


    // MonolithicDeploymentDescription

    MonolithicDeploymentDescription::MonolithicDeploymentDescription (::XMLSchema::string<ACE_TCHAR> const& name__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    {
      name_->container (this);
    }

    MonolithicDeploymentDescription::MonolithicDeploymentDescription (MonolithicDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , source_ (s.source_)
    , artifact_ (s.artifact_)
    , execParameter_ (s.execParameter_)
    , deployRequirement_ (s.deployRequirement_)
    , id_ (s.id_.get () ? new ::XMLSchema::ID<ACE_TCHAR> (*s.id_) : 0)
    {
      name_->container (this);
      if (id_.get ()) id_->container (this);
    }

    MonolithicDeploymentDescription&
    MonolithicDeploymentDescription::operator= (MonolithicDeploymentDescription const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        source_ = s.source_;

        artifact_ = s.artifact_;

        execParameter_ = s.execParameter_;

        deployRequirement_ = s.deployRequirement_;

        if (s.id_.get ()) id (*(s.id_));
        else id_.reset (0);
      }

      return *this;
    }


    // MonolithicDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& MonolithicDeploymentDescription::
    name () const
    {
      return *name_;
    }

    void MonolithicDeploymentDescription::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // MonolithicDeploymentDescription
    MonolithicDeploymentDescription::source_iterator MonolithicDeploymentDescription::
    begin_source ()
    {
      return source_.begin ();
    }

    MonolithicDeploymentDescription::source_iterator MonolithicDeploymentDescription::
    end_source ()
    {
      return source_.end ();
    }

    MonolithicDeploymentDescription::source_const_iterator MonolithicDeploymentDescription::
    begin_source () const
    {
      return source_.begin ();
    }

    MonolithicDeploymentDescription::source_const_iterator MonolithicDeploymentDescription::
    end_source () const
    {
      return source_.end ();
    }

    void MonolithicDeploymentDescription::
    add_source (MonolithicDeploymentDescription::source_value_type const& e)
    {
      source_.push_back (e);
    }

    size_t MonolithicDeploymentDescription::
    count_source(void) const
    {
      return source_.size ();
    }

    // MonolithicDeploymentDescription
    MonolithicDeploymentDescription::artifact_iterator MonolithicDeploymentDescription::
    begin_artifact ()
    {
      return artifact_.begin ();
    }

    MonolithicDeploymentDescription::artifact_iterator MonolithicDeploymentDescription::
    end_artifact ()
    {
      return artifact_.end ();
    }

    MonolithicDeploymentDescription::artifact_const_iterator MonolithicDeploymentDescription::
    begin_artifact () const
    {
      return artifact_.begin ();
    }

    MonolithicDeploymentDescription::artifact_const_iterator MonolithicDeploymentDescription::
    end_artifact () const
    {
      return artifact_.end ();
    }

    void MonolithicDeploymentDescription::
    add_artifact (MonolithicDeploymentDescription::artifact_value_type const& e)
    {
      artifact_.push_back (e);
    }

    size_t MonolithicDeploymentDescription::
    count_artifact(void) const
    {
      return artifact_.size ();
    }

    // MonolithicDeploymentDescription
    MonolithicDeploymentDescription::execParameter_iterator MonolithicDeploymentDescription::
    begin_execParameter ()
    {
      return execParameter_.begin ();
    }

    MonolithicDeploymentDescription::execParameter_iterator MonolithicDeploymentDescription::
    end_execParameter ()
    {
      return execParameter_.end ();
    }

    MonolithicDeploymentDescription::execParameter_const_iterator MonolithicDeploymentDescription::
    begin_execParameter () const
    {
      return execParameter_.begin ();
    }

    MonolithicDeploymentDescription::execParameter_const_iterator MonolithicDeploymentDescription::
    end_execParameter () const
    {
      return execParameter_.end ();
    }

    void MonolithicDeploymentDescription::
    add_execParameter (MonolithicDeploymentDescription::execParameter_value_type const& e)
    {
      execParameter_.push_back (e);
    }

    size_t MonolithicDeploymentDescription::
    count_execParameter(void) const
    {
      return execParameter_.size ();
    }

    // MonolithicDeploymentDescription
    MonolithicDeploymentDescription::deployRequirement_iterator MonolithicDeploymentDescription::
    begin_deployRequirement ()
    {
      return deployRequirement_.begin ();
    }

    MonolithicDeploymentDescription::deployRequirement_iterator MonolithicDeploymentDescription::
    end_deployRequirement ()
    {
      return deployRequirement_.end ();
    }

    MonolithicDeploymentDescription::deployRequirement_const_iterator MonolithicDeploymentDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.begin ();
    }

    MonolithicDeploymentDescription::deployRequirement_const_iterator MonolithicDeploymentDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.end ();
    }

    void MonolithicDeploymentDescription::
    add_deployRequirement (MonolithicDeploymentDescription::deployRequirement_value_type const& e)
    {
      deployRequirement_.push_back (e);
    }

    size_t MonolithicDeploymentDescription::
    count_deployRequirement(void) const
    {
      return deployRequirement_.size ();
    }

    // MonolithicDeploymentDescription
    bool MonolithicDeploymentDescription::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID<ACE_TCHAR> const& MonolithicDeploymentDescription::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID<ACE_TCHAR>& MonolithicDeploymentDescription::
    id ()
    {
      return *id_;
    }

    void MonolithicDeploymentDescription::
    id (::XMLSchema::ID<ACE_TCHAR> const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = MonolithicDeploymentDescription::id_auto_ptr_type (new ::XMLSchema::ID<ACE_TCHAR> (e));
        id_->container (this);
      }
    }


    // ResourceUsageKind

    ResourceUsageKind::Value ResourceUsageKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::ResourceUsageKind const& a, ::DAnCE::Config_Handlers::ResourceUsageKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::ResourceUsageKind const& a, ::DAnCE::Config_Handlers::ResourceUsageKind const& b)
    {
      return a.v_ != b.v_;
    }

    ResourceUsageKind::
    ResourceUsageKind (ResourceUsageKind::Value v)
    : v_ (v)
    {
    }

    // InstanceResourceDeploymentDescription

    InstanceResourceDeploymentDescription::InstanceResourceDeploymentDescription (::DAnCE::Config_Handlers::ResourceUsageKind const& resourceUsage__,
                                                                                  ::XMLSchema::string<ACE_TCHAR> const& requirementName__,
                                                                                  ::XMLSchema::string<ACE_TCHAR> const& resourceName__)
    : ::XSCRT::Type ()
    , resourceUsage_ (new ::DAnCE::Config_Handlers::ResourceUsageKind (resourceUsage__))
    , requirementName_ (new ::XMLSchema::string<ACE_TCHAR> (requirementName__))
    , resourceName_ (new ::XMLSchema::string<ACE_TCHAR> (resourceName__))
    {
      resourceUsage_->container (this);
      requirementName_->container (this);
      resourceName_->container (this);
    }

    InstanceResourceDeploymentDescription::InstanceResourceDeploymentDescription (InstanceResourceDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , resourceUsage_ (new ::DAnCE::Config_Handlers::ResourceUsageKind (*s.resourceUsage_))
    , requirementName_ (new ::XMLSchema::string<ACE_TCHAR> (*s.requirementName_))
    , resourceName_ (new ::XMLSchema::string<ACE_TCHAR> (*s.resourceName_))
    , property_ (s.property_)
    {
      resourceUsage_->container (this);
      requirementName_->container (this);
      resourceName_->container (this);
    }

    InstanceResourceDeploymentDescription&
    InstanceResourceDeploymentDescription::operator= (InstanceResourceDeploymentDescription const& s)
    {
      if (&s != this)
      {
        resourceUsage (*s.resourceUsage_);

        requirementName (*s.requirementName_);

        resourceName (*s.resourceName_);

        property_ = s.property_;
      }

      return *this;
    }


    // InstanceResourceDeploymentDescription
    ::DAnCE::Config_Handlers::ResourceUsageKind const& InstanceResourceDeploymentDescription::
    resourceUsage () const
    {
      return *resourceUsage_;
    }

    void InstanceResourceDeploymentDescription::
    resourceUsage (::DAnCE::Config_Handlers::ResourceUsageKind const& e)
    {
      *resourceUsage_ = e;
    }

    // InstanceResourceDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& InstanceResourceDeploymentDescription::
    requirementName () const
    {
      return *requirementName_;
    }

    void InstanceResourceDeploymentDescription::
    requirementName (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *requirementName_ = e;
    }

    // InstanceResourceDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& InstanceResourceDeploymentDescription::
    resourceName () const
    {
      return *resourceName_;
    }

    void InstanceResourceDeploymentDescription::
    resourceName (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *resourceName_ = e;
    }

    // InstanceResourceDeploymentDescription
    InstanceResourceDeploymentDescription::property_iterator InstanceResourceDeploymentDescription::
    begin_property ()
    {
      return property_.begin ();
    }

    InstanceResourceDeploymentDescription::property_iterator InstanceResourceDeploymentDescription::
    end_property ()
    {
      return property_.end ();
    }

    InstanceResourceDeploymentDescription::property_const_iterator InstanceResourceDeploymentDescription::
    begin_property () const
    {
      return property_.begin ();
    }

    InstanceResourceDeploymentDescription::property_const_iterator InstanceResourceDeploymentDescription::
    end_property () const
    {
      return property_.end ();
    }

    void InstanceResourceDeploymentDescription::
    add_property (InstanceResourceDeploymentDescription::property_value_type const& e)
    {
      property_.push_back (e);
    }

    size_t InstanceResourceDeploymentDescription::
    count_property(void) const
    {
      return property_.size ();
    }


    // InstanceDeploymentDescription

    InstanceDeploymentDescription::InstanceDeploymentDescription (::XMLSchema::string<ACE_TCHAR> const& name__,
                                                                  ::XMLSchema::string<ACE_TCHAR> const& node__,
                                                                  ::XMLSchema::string<ACE_TCHAR> const& source__,
                                                                  ::DAnCE::Config_Handlers::IdRef const& implementation__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , node_ (new ::XMLSchema::string<ACE_TCHAR> (node__))
    , source_ (new ::XMLSchema::string<ACE_TCHAR> (source__))
    , implementation_ (new ::DAnCE::Config_Handlers::IdRef (implementation__))
    {
      name_->container (this);
      node_->container (this);
      source_->container (this);
      implementation_->container (this);
    }

    InstanceDeploymentDescription::InstanceDeploymentDescription (InstanceDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , node_ (new ::XMLSchema::string<ACE_TCHAR> (*s.node_))
    , source_ (new ::XMLSchema::string<ACE_TCHAR> (*s.source_))
    , implementation_ (new ::DAnCE::Config_Handlers::IdRef (*s.implementation_))
    , configProperty_ (s.configProperty_)
    , deployedResource_ (s.deployedResource_)
    , deployedSharedResource_ (s.deployedSharedResource_.get () ? new ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription (*s.deployedSharedResource_) : 0)
    , id_ (s.id_.get () ? new ::XMLSchema::ID<ACE_TCHAR> (*s.id_) : 0)
    {
      name_->container (this);
      node_->container (this);
      source_->container (this);
      implementation_->container (this);
      if (deployedSharedResource_.get ()) deployedSharedResource_->container (this);
      if (id_.get ()) id_->container (this);
    }

    InstanceDeploymentDescription&
    InstanceDeploymentDescription::operator= (InstanceDeploymentDescription const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        node (*s.node_);

        source (*s.source_);

        implementation (*s.implementation_);

        configProperty_ = s.configProperty_;

        deployedResource_ = s.deployedResource_;

        if (s.deployedSharedResource_.get ())
          deployedSharedResource (*(s.deployedSharedResource_));
        else
          deployedSharedResource_.reset (0);

        if (s.id_.get ()) id (*(s.id_));
        else id_.reset (0);
      }

      return *this;
    }


    // InstanceDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& InstanceDeploymentDescription::
    name () const
    {
      return *name_;
    }

    void InstanceDeploymentDescription::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // InstanceDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& InstanceDeploymentDescription::
    node () const
    {
      return *node_;
    }

    void InstanceDeploymentDescription::
    node (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *node_ = e;
    }

    // InstanceDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& InstanceDeploymentDescription::
    source () const
    {
      return *source_;
    }

    void InstanceDeploymentDescription::
    source (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *source_ = e;
    }

    // InstanceDeploymentDescription
    ::DAnCE::Config_Handlers::IdRef const& InstanceDeploymentDescription::
    implementation () const
    {
      return *implementation_;
    }

    void InstanceDeploymentDescription::
    implementation (::DAnCE::Config_Handlers::IdRef const& e)
    {
      *implementation_ = e;
    }

    // InstanceDeploymentDescription
    InstanceDeploymentDescription::configProperty_iterator InstanceDeploymentDescription::
    begin_configProperty ()
    {
      return configProperty_.begin ();
    }

    InstanceDeploymentDescription::configProperty_iterator InstanceDeploymentDescription::
    end_configProperty ()
    {
      return configProperty_.end ();
    }

    InstanceDeploymentDescription::configProperty_const_iterator InstanceDeploymentDescription::
    begin_configProperty () const
    {
      return configProperty_.begin ();
    }

    InstanceDeploymentDescription::configProperty_const_iterator InstanceDeploymentDescription::
    end_configProperty () const
    {
      return configProperty_.end ();
    }

    void InstanceDeploymentDescription::
    add_configProperty (InstanceDeploymentDescription::configProperty_value_type const& e)
    {
      configProperty_.push_back (e);
    }

    size_t InstanceDeploymentDescription::
    count_configProperty(void) const
    {
      return configProperty_.size ();
    }

    // InstanceDeploymentDescription
    InstanceDeploymentDescription::deployedResource_iterator InstanceDeploymentDescription::
    begin_deployedResource ()
    {
      return deployedResource_.begin ();
    }

    InstanceDeploymentDescription::deployedResource_iterator InstanceDeploymentDescription::
    end_deployedResource ()
    {
      return deployedResource_.end ();
    }

    InstanceDeploymentDescription::deployedResource_const_iterator InstanceDeploymentDescription::
    begin_deployedResource () const
    {
      return deployedResource_.begin ();
    }

    InstanceDeploymentDescription::deployedResource_const_iterator InstanceDeploymentDescription::
    end_deployedResource () const
    {
      return deployedResource_.end ();
    }

    void InstanceDeploymentDescription::
    add_deployedResource (InstanceDeploymentDescription::deployedResource_value_type const& e)
    {
      deployedResource_.push_back (e);
    }

    size_t InstanceDeploymentDescription::
    count_deployedResource(void) const
    {
      return deployedResource_.size ();
    }

    // InstanceDeploymentDescription
    bool InstanceDeploymentDescription::
    deployedSharedResource_p () const
    {
      return deployedSharedResource_.get () != 0;
    }

    ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription const& InstanceDeploymentDescription::
    deployedSharedResource () const
    {
      return *deployedSharedResource_;
    }

    void InstanceDeploymentDescription::
    deployedSharedResource (::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription const& e)
    {
      if (deployedSharedResource_.get ())
      {
        *deployedSharedResource_ = e;
      }

      else
      {
        deployedSharedResource_ = InstanceDeploymentDescription::deployedSharedResource_auto_ptr_type (new ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription (e));
        deployedSharedResource_->container (this);
      }
    }

    // InstanceDeploymentDescription
    bool InstanceDeploymentDescription::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID<ACE_TCHAR> const& InstanceDeploymentDescription::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID<ACE_TCHAR>& InstanceDeploymentDescription::
    id ()
    {
      return *id_;
    }

    void InstanceDeploymentDescription::
    id (::XMLSchema::ID<ACE_TCHAR> const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = InstanceDeploymentDescription::id_auto_ptr_type (new ::XMLSchema::ID<ACE_TCHAR> (e));
        id_->container (this);
      }
    }


    // CCMComponentPortKind

    CCMComponentPortKind::Value CCMComponentPortKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::CCMComponentPortKind const& a, ::DAnCE::Config_Handlers::CCMComponentPortKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::CCMComponentPortKind const& a, ::DAnCE::Config_Handlers::CCMComponentPortKind const& b)
    {
      return a.v_ != b.v_;
    }

    CCMComponentPortKind::
    CCMComponentPortKind (CCMComponentPortKind::Value v)
    : v_ (v)
    {
    }

    // ComponentPortDescription

    ComponentPortDescription::ComponentPortDescription (::XMLSchema::string<ACE_TCHAR> const& name__,
                                                        ::XMLSchema::boolean const& provider__,
                                                        ::XMLSchema::boolean const& exclusiveProvider__,
                                                        ::XMLSchema::boolean const& exclusiveUser__,
                                                        ::XMLSchema::boolean const& optional__,
                                                        ::DAnCE::Config_Handlers::CCMComponentPortKind const& kind__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , provider_ (new ::XMLSchema::boolean (provider__))
    , exclusiveProvider_ (new ::XMLSchema::boolean (exclusiveProvider__))
    , exclusiveUser_ (new ::XMLSchema::boolean (exclusiveUser__))
    , optional_ (new ::XMLSchema::boolean (optional__))
    , kind_ (new ::DAnCE::Config_Handlers::CCMComponentPortKind (kind__))
    {
      name_->container (this);
      provider_->container (this);
      exclusiveProvider_->container (this);
      exclusiveUser_->container (this);
      optional_->container (this);
      kind_->container (this);
    }

    ComponentPortDescription::ComponentPortDescription (ComponentPortDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , specificType_ (s.specificType_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.specificType_) : 0)
    , supportedType_ (s.supportedType_)
    , provider_ (new ::XMLSchema::boolean (*s.provider_))
    , exclusiveProvider_ (new ::XMLSchema::boolean (*s.exclusiveProvider_))
    , exclusiveUser_ (new ::XMLSchema::boolean (*s.exclusiveUser_))
    , optional_ (new ::XMLSchema::boolean (*s.optional_))
    , kind_ (new ::DAnCE::Config_Handlers::CCMComponentPortKind (*s.kind_))
    , templateParam_ (s.templateParam_)
    {
      name_->container (this);
      if (specificType_.get ()) specificType_->container (this);
      provider_->container (this);
      exclusiveProvider_->container (this);
      exclusiveUser_->container (this);
      optional_->container (this);
      kind_->container (this);
    }

    ComponentPortDescription&
    ComponentPortDescription::operator= (ComponentPortDescription const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        if (s.specificType_.get ())
          specificType (*(s.specificType_));
        else
          specificType_.reset (0);

        supportedType_ = s.supportedType_;

        provider (*s.provider_);

        exclusiveProvider (*s.exclusiveProvider_);

        exclusiveUser (*s.exclusiveUser_);

        optional (*s.optional_);

        kind (*s.kind_);

        templateParam_ = s.templateParam_;
      }

      return *this;
    }


    // ComponentPortDescription
    ::XMLSchema::string<ACE_TCHAR> const& ComponentPortDescription::
    name () const
    {
      return *name_;
    }

    void ComponentPortDescription::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // ComponentPortDescription
    bool ComponentPortDescription::
    specificType_p () const
    {
      return specificType_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ComponentPortDescription::
    specificType () const
    {
      return *specificType_;
    }

    void ComponentPortDescription::
    specificType (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (specificType_.get ())
      {
        *specificType_ = e;
      }

      else
      {
        specificType_ = ComponentPortDescription::specificType_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        specificType_->container (this);
      }
    }

    // ComponentPortDescription
    ComponentPortDescription::supportedType_iterator ComponentPortDescription::
    begin_supportedType ()
    {
      return supportedType_.begin ();
    }

    ComponentPortDescription::supportedType_iterator ComponentPortDescription::
    end_supportedType ()
    {
      return supportedType_.end ();
    }

    ComponentPortDescription::supportedType_const_iterator ComponentPortDescription::
    begin_supportedType () const
    {
      return supportedType_.begin ();
    }

    ComponentPortDescription::supportedType_const_iterator ComponentPortDescription::
    end_supportedType () const
    {
      return supportedType_.end ();
    }

    void ComponentPortDescription::
    add_supportedType (ComponentPortDescription::supportedType_value_type const& e)
    {
      supportedType_.push_back (e);
    }

    size_t ComponentPortDescription::
    count_supportedType(void) const
    {
      return supportedType_.size ();
    }

    // ComponentPortDescription
    ::XMLSchema::boolean const& ComponentPortDescription::
    provider () const
    {
      return *provider_;
    }

    void ComponentPortDescription::
    provider (::XMLSchema::boolean const& e)
    {
      *provider_ = e;
    }

    // ComponentPortDescription
    ::XMLSchema::boolean const& ComponentPortDescription::
    exclusiveProvider () const
    {
      return *exclusiveProvider_;
    }

    void ComponentPortDescription::
    exclusiveProvider (::XMLSchema::boolean const& e)
    {
      *exclusiveProvider_ = e;
    }

    // ComponentPortDescription
    ::XMLSchema::boolean const& ComponentPortDescription::
    exclusiveUser () const
    {
      return *exclusiveUser_;
    }

    void ComponentPortDescription::
    exclusiveUser (::XMLSchema::boolean const& e)
    {
      *exclusiveUser_ = e;
    }

    // ComponentPortDescription
    ::XMLSchema::boolean const& ComponentPortDescription::
    optional () const
    {
      return *optional_;
    }

    void ComponentPortDescription::
    optional (::XMLSchema::boolean const& e)
    {
      *optional_ = e;
    }

    // ComponentPortDescription
    ::DAnCE::Config_Handlers::CCMComponentPortKind const& ComponentPortDescription::
    kind () const
    {
      return *kind_;
    }

    void ComponentPortDescription::
    kind (::DAnCE::Config_Handlers::CCMComponentPortKind const& e)
    {
      *kind_ = e;
    }

    // ComponentPortDescription
    ComponentPortDescription::templateParam_iterator ComponentPortDescription::
    begin_templateParam ()
    {
      return templateParam_.begin ();
    }

    ComponentPortDescription::templateParam_iterator ComponentPortDescription::
    end_templateParam ()
    {
      return templateParam_.end ();
    }

    ComponentPortDescription::templateParam_const_iterator ComponentPortDescription::
    begin_templateParam () const
    {
      return templateParam_.begin ();
    }

    ComponentPortDescription::templateParam_const_iterator ComponentPortDescription::
    end_templateParam () const
    {
      return templateParam_.end ();
    }

    void ComponentPortDescription::
    add_templateParam (ComponentPortDescription::templateParam_value_type const& e)
    {
      templateParam_.push_back (e);
    }

    size_t ComponentPortDescription::
    count_templateParam(void) const
    {
      return templateParam_.size ();
    }


    // ComponentPropertyDescription

    ComponentPropertyDescription::ComponentPropertyDescription (::XMLSchema::string<ACE_TCHAR> const& name__,
                                                                ::DAnCE::Config_Handlers::DataType const& type__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , type_ (new ::DAnCE::Config_Handlers::DataType (type__))
    {
      name_->container (this);
      type_->container (this);
    }

    ComponentPropertyDescription::ComponentPropertyDescription (ComponentPropertyDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , type_ (new ::DAnCE::Config_Handlers::DataType (*s.type_))
    {
      name_->container (this);
      type_->container (this);
    }

    ComponentPropertyDescription&
    ComponentPropertyDescription::operator= (ComponentPropertyDescription const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        type (*s.type_);
      }

      return *this;
    }


    // ComponentPropertyDescription
    ::XMLSchema::string<ACE_TCHAR> const& ComponentPropertyDescription::
    name () const
    {
      return *name_;
    }

    void ComponentPropertyDescription::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // ComponentPropertyDescription
    ::DAnCE::Config_Handlers::DataType const& ComponentPropertyDescription::
    type () const
    {
      return *type_;
    }

    void ComponentPropertyDescription::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }


    // ComponentExternalPortEndpoint

    ComponentExternalPortEndpoint::ComponentExternalPortEndpoint (::XMLSchema::string<ACE_TCHAR> const& portName__)
    : ::XSCRT::Type ()
    , portName_ (new ::XMLSchema::string<ACE_TCHAR> (portName__))
    {
      portName_->container (this);
    }

    ComponentExternalPortEndpoint::ComponentExternalPortEndpoint (ComponentExternalPortEndpoint const& s) :
    ::XSCRT::Type (s)
    , portName_ (new ::XMLSchema::string<ACE_TCHAR> (*s.portName_))
    {
      portName_->container (this);
    }

    ComponentExternalPortEndpoint&
    ComponentExternalPortEndpoint::operator= (ComponentExternalPortEndpoint const& s)
    {
      if (&s != this)
      {
        portName (*s.portName_);
      }

      return *this;
    }


    // ComponentExternalPortEndpoint
    ::XMLSchema::string<ACE_TCHAR> const& ComponentExternalPortEndpoint::
    portName () const
    {
      return *portName_;
    }

    void ComponentExternalPortEndpoint::
    portName (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *portName_ = e;
    }


    // PlanSubcomponentPortEndpoint

    PlanSubcomponentPortEndpoint::PlanSubcomponentPortEndpoint (::XMLSchema::string<ACE_TCHAR> const& portName__,
                                                                ::DAnCE::Config_Handlers::CCMComponentPortKind const& kind__,
                                                                ::DAnCE::Config_Handlers::IdRef const& instance__)
    : ::XSCRT::Type ()
    , portName_ (new ::XMLSchema::string<ACE_TCHAR> (portName__))
    , kind_ (new ::DAnCE::Config_Handlers::CCMComponentPortKind (kind__))
    , instance_ (new ::DAnCE::Config_Handlers::IdRef (instance__))
    {
      portName_->container (this);
      kind_->container (this);
      instance_->container (this);
    }

    PlanSubcomponentPortEndpoint::PlanSubcomponentPortEndpoint (PlanSubcomponentPortEndpoint const& s) :
    ::XSCRT::Type (s)
    , portName_ (new ::XMLSchema::string<ACE_TCHAR> (*s.portName_))
    , provider_ (s.provider_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.provider_) : 0)
    , kind_ (new ::DAnCE::Config_Handlers::CCMComponentPortKind (*s.kind_))
    , instance_ (new ::DAnCE::Config_Handlers::IdRef (*s.instance_))
    {
      portName_->container (this);
      if (provider_.get ()) provider_->container (this);
      kind_->container (this);
      instance_->container (this);
    }

    PlanSubcomponentPortEndpoint&
    PlanSubcomponentPortEndpoint::operator= (PlanSubcomponentPortEndpoint const& s)
    {
      if (&s != this)
      {
        portName (*s.portName_);

        if (s.provider_.get ())
          provider (*(s.provider_));
        else
          provider_.reset (0);

        kind (*s.kind_);

        instance (*s.instance_);
      }

      return *this;
    }


    // PlanSubcomponentPortEndpoint
    ::XMLSchema::string<ACE_TCHAR> const& PlanSubcomponentPortEndpoint::
    portName () const
    {
      return *portName_;
    }

    void PlanSubcomponentPortEndpoint::
    portName (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *portName_ = e;
    }

    // PlanSubcomponentPortEndpoint
    bool PlanSubcomponentPortEndpoint::
    provider_p () const
    {
      return provider_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& PlanSubcomponentPortEndpoint::
    provider () const
    {
      return *provider_;
    }

    void PlanSubcomponentPortEndpoint::
    provider (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (provider_.get ())
      {
        *provider_ = e;
      }

      else
      {
        provider_ = PlanSubcomponentPortEndpoint::provider_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        provider_->container (this);
      }
    }

    // PlanSubcomponentPortEndpoint
    ::DAnCE::Config_Handlers::CCMComponentPortKind const& PlanSubcomponentPortEndpoint::
    kind () const
    {
      return *kind_;
    }

    void PlanSubcomponentPortEndpoint::
    kind (::DAnCE::Config_Handlers::CCMComponentPortKind const& e)
    {
      *kind_ = e;
    }

    // PlanSubcomponentPortEndpoint
    ::DAnCE::Config_Handlers::IdRef const& PlanSubcomponentPortEndpoint::
    instance () const
    {
      return *instance_;
    }

    void PlanSubcomponentPortEndpoint::
    instance (::DAnCE::Config_Handlers::IdRef const& e)
    {
      *instance_ = e;
    }


    // ExternalReferenceEndpoint

    ExternalReferenceEndpoint::ExternalReferenceEndpoint (::XMLSchema::string<ACE_TCHAR> const& location__,
                                                          ::XMLSchema::boolean const& provider__)
    : ::XSCRT::Type ()
    , location_ (new ::XMLSchema::string<ACE_TCHAR> (location__))
    , provider_ (new ::XMLSchema::boolean (provider__))
    {
      location_->container (this);
      provider_->container (this);
    }

    ExternalReferenceEndpoint::ExternalReferenceEndpoint (ExternalReferenceEndpoint const& s) :
    ::XSCRT::Type (s)
    , location_ (new ::XMLSchema::string<ACE_TCHAR> (*s.location_))
    , provider_ (new ::XMLSchema::boolean (*s.provider_))
    , portName_ (s.portName_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.portName_) : 0)
    , supportedType_ (s.supportedType_)
    {
      location_->container (this);
      provider_->container (this);
      if (portName_.get ()) portName_->container (this);
    }

    ExternalReferenceEndpoint&
    ExternalReferenceEndpoint::operator= (ExternalReferenceEndpoint const& s)
    {
      if (&s != this)
      {
        location (*s.location_);

        provider (*s.provider_);

        if (s.portName_.get ())
          portName (*(s.portName_));
        else
          portName_.reset (0);

        supportedType_ = s.supportedType_;
      }

      return *this;
    }


    // ExternalReferenceEndpoint
    ::XMLSchema::string<ACE_TCHAR> const& ExternalReferenceEndpoint::
    location () const
    {
      return *location_;
    }

    void ExternalReferenceEndpoint::
    location (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *location_ = e;
    }

    // ExternalReferenceEndpoint
    ::XMLSchema::boolean const& ExternalReferenceEndpoint::
    provider () const
    {
      return *provider_;
    }

    void ExternalReferenceEndpoint::
    provider (::XMLSchema::boolean const& e)
    {
      *provider_ = e;
    }

    // ExternalReferenceEndpoint
    bool ExternalReferenceEndpoint::
    portName_p () const
    {
      return portName_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ExternalReferenceEndpoint::
    portName () const
    {
      return *portName_;
    }

    void ExternalReferenceEndpoint::
    portName (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (portName_.get ())
      {
        *portName_ = e;
      }

      else
      {
        portName_ = ExternalReferenceEndpoint::portName_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        portName_->container (this);
      }
    }

    // ExternalReferenceEndpoint
    ExternalReferenceEndpoint::supportedType_iterator ExternalReferenceEndpoint::
    begin_supportedType ()
    {
      return supportedType_.begin ();
    }

    ExternalReferenceEndpoint::supportedType_iterator ExternalReferenceEndpoint::
    end_supportedType ()
    {
      return supportedType_.end ();
    }

    ExternalReferenceEndpoint::supportedType_const_iterator ExternalReferenceEndpoint::
    begin_supportedType () const
    {
      return supportedType_.begin ();
    }

    ExternalReferenceEndpoint::supportedType_const_iterator ExternalReferenceEndpoint::
    end_supportedType () const
    {
      return supportedType_.end ();
    }

    void ExternalReferenceEndpoint::
    add_supportedType (ExternalReferenceEndpoint::supportedType_value_type const& e)
    {
      supportedType_.push_back (e);
    }

    size_t ExternalReferenceEndpoint::
    count_supportedType(void) const
    {
      return supportedType_.size ();
    }


    // ConnectionResourceDeploymentDescription

    ConnectionResourceDeploymentDescription::ConnectionResourceDeploymentDescription (::XMLSchema::string<ACE_TCHAR> const& targetName__,
                                                                                      ::XMLSchema::string<ACE_TCHAR> const& requirementName__,
                                                                                      ::XMLSchema::string<ACE_TCHAR> const& resourceName__)
    : ::XSCRT::Type ()
    , targetName_ (new ::XMLSchema::string<ACE_TCHAR> (targetName__))
    , requirementName_ (new ::XMLSchema::string<ACE_TCHAR> (requirementName__))
    , resourceName_ (new ::XMLSchema::string<ACE_TCHAR> (resourceName__))
    {
      targetName_->container (this);
      requirementName_->container (this);
      resourceName_->container (this);
    }

    ConnectionResourceDeploymentDescription::ConnectionResourceDeploymentDescription (ConnectionResourceDeploymentDescription const& s) :
    ::XSCRT::Type (s)
    , targetName_ (new ::XMLSchema::string<ACE_TCHAR> (*s.targetName_))
    , requirementName_ (new ::XMLSchema::string<ACE_TCHAR> (*s.requirementName_))
    , resourceName_ (new ::XMLSchema::string<ACE_TCHAR> (*s.resourceName_))
    , property_ (s.property_)
    {
      targetName_->container (this);
      requirementName_->container (this);
      resourceName_->container (this);
    }

    ConnectionResourceDeploymentDescription&
    ConnectionResourceDeploymentDescription::operator= (ConnectionResourceDeploymentDescription const& s)
    {
      if (&s != this)
      {
        targetName (*s.targetName_);

        requirementName (*s.requirementName_);

        resourceName (*s.resourceName_);

        property_ = s.property_;
      }

      return *this;
    }


    // ConnectionResourceDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& ConnectionResourceDeploymentDescription::
    targetName () const
    {
      return *targetName_;
    }

    void ConnectionResourceDeploymentDescription::
    targetName (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *targetName_ = e;
    }

    // ConnectionResourceDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& ConnectionResourceDeploymentDescription::
    requirementName () const
    {
      return *requirementName_;
    }

    void ConnectionResourceDeploymentDescription::
    requirementName (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *requirementName_ = e;
    }

    // ConnectionResourceDeploymentDescription
    ::XMLSchema::string<ACE_TCHAR> const& ConnectionResourceDeploymentDescription::
    resourceName () const
    {
      return *resourceName_;
    }

    void ConnectionResourceDeploymentDescription::
    resourceName (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *resourceName_ = e;
    }

    // ConnectionResourceDeploymentDescription
    ConnectionResourceDeploymentDescription::property_iterator ConnectionResourceDeploymentDescription::
    begin_property ()
    {
      return property_.begin ();
    }

    ConnectionResourceDeploymentDescription::property_iterator ConnectionResourceDeploymentDescription::
    end_property ()
    {
      return property_.end ();
    }

    ConnectionResourceDeploymentDescription::property_const_iterator ConnectionResourceDeploymentDescription::
    begin_property () const
    {
      return property_.begin ();
    }

    ConnectionResourceDeploymentDescription::property_const_iterator ConnectionResourceDeploymentDescription::
    end_property () const
    {
      return property_.end ();
    }

    void ConnectionResourceDeploymentDescription::
    add_property (ConnectionResourceDeploymentDescription::property_value_type const& e)
    {
      property_.push_back (e);
    }

    size_t ConnectionResourceDeploymentDescription::
    count_property(void) const
    {
      return property_.size ();
    }


    // PlanConnectionDescription

    PlanConnectionDescription::PlanConnectionDescription (::XMLSchema::string<ACE_TCHAR> const& name__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    {
      name_->container (this);
    }

    PlanConnectionDescription::PlanConnectionDescription (PlanConnectionDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , source_ (s.source_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.source_) : 0)
    , deployRequirement_ (s.deployRequirement_)
    , externalEndpoint_ (s.externalEndpoint_)
    , internalEndpoint_ (s.internalEndpoint_)
    , externalReference_ (s.externalReference_)
    , deployedResource_ (s.deployedResource_)
    {
      name_->container (this);
      if (source_.get ()) source_->container (this);
    }

    PlanConnectionDescription&
    PlanConnectionDescription::operator= (PlanConnectionDescription const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        if (s.source_.get ())
          source (*(s.source_));
        else
          source_.reset (0);

        deployRequirement_ = s.deployRequirement_;

        externalEndpoint_ = s.externalEndpoint_;

        internalEndpoint_ = s.internalEndpoint_;

        externalReference_ = s.externalReference_;

        deployedResource_ = s.deployedResource_;
      }

      return *this;
    }


    // PlanConnectionDescription
    ::XMLSchema::string<ACE_TCHAR> const& PlanConnectionDescription::
    name () const
    {
      return *name_;
    }

    void PlanConnectionDescription::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // PlanConnectionDescription
    bool PlanConnectionDescription::
    source_p () const
    {
      return source_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& PlanConnectionDescription::
    source () const
    {
      return *source_;
    }

    void PlanConnectionDescription::
    source (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (source_.get ())
      {
        *source_ = e;
      }

      else
      {
        source_ = PlanConnectionDescription::source_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        source_->container (this);
      }
    }

    // PlanConnectionDescription
    PlanConnectionDescription::deployRequirement_iterator PlanConnectionDescription::
    begin_deployRequirement ()
    {
      return deployRequirement_.begin ();
    }

    PlanConnectionDescription::deployRequirement_iterator PlanConnectionDescription::
    end_deployRequirement ()
    {
      return deployRequirement_.end ();
    }

    PlanConnectionDescription::deployRequirement_const_iterator PlanConnectionDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.begin ();
    }

    PlanConnectionDescription::deployRequirement_const_iterator PlanConnectionDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.end ();
    }

    void PlanConnectionDescription::
    add_deployRequirement (PlanConnectionDescription::deployRequirement_value_type const& e)
    {
      deployRequirement_.push_back (e);
    }

    size_t PlanConnectionDescription::
    count_deployRequirement(void) const
    {
      return deployRequirement_.size ();
    }

    // PlanConnectionDescription
    PlanConnectionDescription::externalEndpoint_iterator PlanConnectionDescription::
    begin_externalEndpoint ()
    {
      return externalEndpoint_.begin ();
    }

    PlanConnectionDescription::externalEndpoint_iterator PlanConnectionDescription::
    end_externalEndpoint ()
    {
      return externalEndpoint_.end ();
    }

    PlanConnectionDescription::externalEndpoint_const_iterator PlanConnectionDescription::
    begin_externalEndpoint () const
    {
      return externalEndpoint_.begin ();
    }

    PlanConnectionDescription::externalEndpoint_const_iterator PlanConnectionDescription::
    end_externalEndpoint () const
    {
      return externalEndpoint_.end ();
    }

    void PlanConnectionDescription::
    add_externalEndpoint (PlanConnectionDescription::externalEndpoint_value_type const& e)
    {
      externalEndpoint_.push_back (e);
    }

    size_t PlanConnectionDescription::
    count_externalEndpoint(void) const
    {
      return externalEndpoint_.size ();
    }

    // PlanConnectionDescription
    PlanConnectionDescription::internalEndpoint_iterator PlanConnectionDescription::
    begin_internalEndpoint ()
    {
      return internalEndpoint_.begin ();
    }

    PlanConnectionDescription::internalEndpoint_iterator PlanConnectionDescription::
    end_internalEndpoint ()
    {
      return internalEndpoint_.end ();
    }

    PlanConnectionDescription::internalEndpoint_const_iterator PlanConnectionDescription::
    begin_internalEndpoint () const
    {
      return internalEndpoint_.begin ();
    }

    PlanConnectionDescription::internalEndpoint_const_iterator PlanConnectionDescription::
    end_internalEndpoint () const
    {
      return internalEndpoint_.end ();
    }

    void PlanConnectionDescription::
    add_internalEndpoint (PlanConnectionDescription::internalEndpoint_value_type const& e)
    {
      internalEndpoint_.push_back (e);
    }

    size_t PlanConnectionDescription::
    count_internalEndpoint(void) const
    {
      return internalEndpoint_.size ();
    }

    // PlanConnectionDescription
    PlanConnectionDescription::externalReference_iterator PlanConnectionDescription::
    begin_externalReference ()
    {
      return externalReference_.begin ();
    }

    PlanConnectionDescription::externalReference_iterator PlanConnectionDescription::
    end_externalReference ()
    {
      return externalReference_.end ();
    }

    PlanConnectionDescription::externalReference_const_iterator PlanConnectionDescription::
    begin_externalReference () const
    {
      return externalReference_.begin ();
    }

    PlanConnectionDescription::externalReference_const_iterator PlanConnectionDescription::
    end_externalReference () const
    {
      return externalReference_.end ();
    }

    void PlanConnectionDescription::
    add_externalReference (PlanConnectionDescription::externalReference_value_type const& e)
    {
      externalReference_.push_back (e);
    }

    size_t PlanConnectionDescription::
    count_externalReference(void) const
    {
      return externalReference_.size ();
    }

    // PlanConnectionDescription
    PlanConnectionDescription::deployedResource_iterator PlanConnectionDescription::
    begin_deployedResource ()
    {
      return deployedResource_.begin ();
    }

    PlanConnectionDescription::deployedResource_iterator PlanConnectionDescription::
    end_deployedResource ()
    {
      return deployedResource_.end ();
    }

    PlanConnectionDescription::deployedResource_const_iterator PlanConnectionDescription::
    begin_deployedResource () const
    {
      return deployedResource_.begin ();
    }

    PlanConnectionDescription::deployedResource_const_iterator PlanConnectionDescription::
    end_deployedResource () const
    {
      return deployedResource_.end ();
    }

    void PlanConnectionDescription::
    add_deployedResource (PlanConnectionDescription::deployedResource_value_type const& e)
    {
      deployedResource_.push_back (e);
    }

    size_t PlanConnectionDescription::
    count_deployedResource(void) const
    {
      return deployedResource_.size ();
    }


    // ImplementationDependency

    ImplementationDependency::ImplementationDependency (::XMLSchema::string<ACE_TCHAR> const& requiredType__)
    : ::XSCRT::Type ()
    , requiredType_ (new ::XMLSchema::string<ACE_TCHAR> (requiredType__))
    {
      requiredType_->container (this);
    }

    ImplementationDependency::ImplementationDependency (ImplementationDependency const& s) :
    ::XSCRT::Type (s)
    , requiredType_ (new ::XMLSchema::string<ACE_TCHAR> (*s.requiredType_))
    {
      requiredType_->container (this);
    }

    ImplementationDependency&
    ImplementationDependency::operator= (ImplementationDependency const& s)
    {
      if (&s != this)
      {
        requiredType (*s.requiredType_);
      }

      return *this;
    }


    // ImplementationDependency
    ::XMLSchema::string<ACE_TCHAR> const& ImplementationDependency::
    requiredType () const
    {
      return *requiredType_;
    }

    void ImplementationDependency::
    requiredType (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *requiredType_ = e;
    }


    // Capability

    Capability::Capability (::XMLSchema::string<ACE_TCHAR> const& name__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    {
      name_->container (this);
    }

    Capability::Capability (Capability const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , resourceType_ (s.resourceType_)
    , property_ (s.property_)
    {
      name_->container (this);
    }

    Capability&
    Capability::operator= (Capability const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        resourceType_ = s.resourceType_;

        property_ = s.property_;
      }

      return *this;
    }


    // Capability
    ::XMLSchema::string<ACE_TCHAR> const& Capability::
    name () const
    {
      return *name_;
    }

    void Capability::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // Capability
    Capability::resourceType_iterator Capability::
    begin_resourceType ()
    {
      return resourceType_.begin ();
    }

    Capability::resourceType_iterator Capability::
    end_resourceType ()
    {
      return resourceType_.end ();
    }

    Capability::resourceType_const_iterator Capability::
    begin_resourceType () const
    {
      return resourceType_.begin ();
    }

    Capability::resourceType_const_iterator Capability::
    end_resourceType () const
    {
      return resourceType_.end ();
    }

    void Capability::
    add_resourceType (Capability::resourceType_value_type const& e)
    {
      resourceType_.push_back (e);
    }

    size_t Capability::
    count_resourceType(void) const
    {
      return resourceType_.size ();
    }

    // Capability
    Capability::property_iterator Capability::
    begin_property ()
    {
      return property_.begin ();
    }

    Capability::property_iterator Capability::
    end_property ()
    {
      return property_.end ();
    }

    Capability::property_const_iterator Capability::
    begin_property () const
    {
      return property_.begin ();
    }

    Capability::property_const_iterator Capability::
    end_property () const
    {
      return property_.end ();
    }

    void Capability::
    add_property (Capability::property_value_type const& e)
    {
      property_.push_back (e);
    }

    size_t Capability::
    count_property(void) const
    {
      return property_.size ();
    }


    // ImplementationRequirement

    ImplementationRequirement::ImplementationRequirement (::XMLSchema::string<ACE_TCHAR> const& resourceType__,
                                                          ::XMLSchema::string<ACE_TCHAR> const& name__)
    : ::XSCRT::Type ()
    , resourceType_ (new ::XMLSchema::string<ACE_TCHAR> (resourceType__))
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    {
      resourceType_->container (this);
      name_->container (this);
    }

    ImplementationRequirement::ImplementationRequirement (ImplementationRequirement const& s) :
    ::XSCRT::Type (s)
    , resourceUsage_ (s.resourceUsage_.get () ? new ::DAnCE::Config_Handlers::ResourceUsageKind (*s.resourceUsage_) : 0)
    , resourcePort_ (s.resourcePort_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.resourcePort_) : 0)
    , componentPort_ (s.componentPort_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.componentPort_) : 0)
    , resourceType_ (new ::XMLSchema::string<ACE_TCHAR> (*s.resourceType_))
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , property_ (s.property_)
    {
      if (resourceUsage_.get ()) resourceUsage_->container (this);
      if (resourcePort_.get ()) resourcePort_->container (this);
      if (componentPort_.get ()) componentPort_->container (this);
      resourceType_->container (this);
      name_->container (this);
    }

    ImplementationRequirement&
    ImplementationRequirement::operator= (ImplementationRequirement const& s)
    {
      if (&s != this)
      {
        if (s.resourceUsage_.get ())
          resourceUsage (*(s.resourceUsage_));
        else
          resourceUsage_.reset (0);

        if (s.resourcePort_.get ())
          resourcePort (*(s.resourcePort_));
        else
          resourcePort_.reset (0);

        if (s.componentPort_.get ())
          componentPort (*(s.componentPort_));
        else
          componentPort_.reset (0);

        resourceType (*s.resourceType_);

        name (*s.name_);

        property_ = s.property_;
      }

      return *this;
    }


    // ImplementationRequirement
    bool ImplementationRequirement::
    resourceUsage_p () const
    {
      return resourceUsage_.get () != 0;
    }

    ::DAnCE::Config_Handlers::ResourceUsageKind const& ImplementationRequirement::
    resourceUsage () const
    {
      return *resourceUsage_;
    }

    void ImplementationRequirement::
    resourceUsage (::DAnCE::Config_Handlers::ResourceUsageKind const& e)
    {
      if (resourceUsage_.get ())
      {
        *resourceUsage_ = e;
      }

      else
      {
        resourceUsage_ = ImplementationRequirement::resourceUsage_auto_ptr_type (new ::DAnCE::Config_Handlers::ResourceUsageKind (e));
        resourceUsage_->container (this);
      }
    }

    // ImplementationRequirement
    bool ImplementationRequirement::
    resourcePort_p () const
    {
      return resourcePort_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ImplementationRequirement::
    resourcePort () const
    {
      return *resourcePort_;
    }

    void ImplementationRequirement::
    resourcePort (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (resourcePort_.get ())
      {
        *resourcePort_ = e;
      }

      else
      {
        resourcePort_ = ImplementationRequirement::resourcePort_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        resourcePort_->container (this);
      }
    }

    // ImplementationRequirement
    bool ImplementationRequirement::
    componentPort_p () const
    {
      return componentPort_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ImplementationRequirement::
    componentPort () const
    {
      return *componentPort_;
    }

    void ImplementationRequirement::
    componentPort (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (componentPort_.get ())
      {
        *componentPort_ = e;
      }

      else
      {
        componentPort_ = ImplementationRequirement::componentPort_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        componentPort_->container (this);
      }
    }

    // ImplementationRequirement
    ::XMLSchema::string<ACE_TCHAR> const& ImplementationRequirement::
    resourceType () const
    {
      return *resourceType_;
    }

    void ImplementationRequirement::
    resourceType (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *resourceType_ = e;
    }

    // ImplementationRequirement
    ::XMLSchema::string<ACE_TCHAR> const& ImplementationRequirement::
    name () const
    {
      return *name_;
    }

    void ImplementationRequirement::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // ImplementationRequirement
    ImplementationRequirement::property_iterator ImplementationRequirement::
    begin_property ()
    {
      return property_.begin ();
    }

    ImplementationRequirement::property_iterator ImplementationRequirement::
    end_property ()
    {
      return property_.end ();
    }

    ImplementationRequirement::property_const_iterator ImplementationRequirement::
    begin_property () const
    {
      return property_.begin ();
    }

    ImplementationRequirement::property_const_iterator ImplementationRequirement::
    end_property () const
    {
      return property_.end ();
    }

    void ImplementationRequirement::
    add_property (ImplementationRequirement::property_value_type const& e)
    {
      property_.push_back (e);
    }

    size_t ImplementationRequirement::
    count_property(void) const
    {
      return property_.size ();
    }


    // SubcomponentPortEndpoint

    SubcomponentPortEndpoint::SubcomponentPortEndpoint (::XMLSchema::string<ACE_TCHAR> const& portName__,
                                                        ::DAnCE::Config_Handlers::IdRef const& instance__)
    : ::XSCRT::Type ()
    , portName_ (new ::XMLSchema::string<ACE_TCHAR> (portName__))
    , instance_ (new ::DAnCE::Config_Handlers::IdRef (instance__))
    {
      portName_->container (this);
      instance_->container (this);
    }

    SubcomponentPortEndpoint::SubcomponentPortEndpoint (SubcomponentPortEndpoint const& s) :
    ::XSCRT::Type (s)
    , portName_ (new ::XMLSchema::string<ACE_TCHAR> (*s.portName_))
    , instance_ (new ::DAnCE::Config_Handlers::IdRef (*s.instance_))
    {
      portName_->container (this);
      instance_->container (this);
    }

    SubcomponentPortEndpoint&
    SubcomponentPortEndpoint::operator= (SubcomponentPortEndpoint const& s)
    {
      if (&s != this)
      {
        portName (*s.portName_);

        instance (*s.instance_);
      }

      return *this;
    }


    // SubcomponentPortEndpoint
    ::XMLSchema::string<ACE_TCHAR> const& SubcomponentPortEndpoint::
    portName () const
    {
      return *portName_;
    }

    void SubcomponentPortEndpoint::
    portName (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *portName_ = e;
    }

    // SubcomponentPortEndpoint
    ::DAnCE::Config_Handlers::IdRef const& SubcomponentPortEndpoint::
    instance () const
    {
      return *instance_;
    }

    void SubcomponentPortEndpoint::
    instance (::DAnCE::Config_Handlers::IdRef const& e)
    {
      *instance_ = e;
    }


    // AssemblyConnectionDescription

    AssemblyConnectionDescription::AssemblyConnectionDescription (::XMLSchema::string<ACE_TCHAR> const& name__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    {
      name_->container (this);
    }

    AssemblyConnectionDescription::AssemblyConnectionDescription (AssemblyConnectionDescription const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , deployRequirement_ (s.deployRequirement_)
    , internalEndpoint_ (s.internalEndpoint_)
    , externalEndpoint_ (s.externalEndpoint_)
    , externalReference_ (s.externalReference_)
    {
      name_->container (this);
    }

    AssemblyConnectionDescription&
    AssemblyConnectionDescription::operator= (AssemblyConnectionDescription const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        deployRequirement_ = s.deployRequirement_;

        internalEndpoint_ = s.internalEndpoint_;

        externalEndpoint_ = s.externalEndpoint_;

        externalReference_ = s.externalReference_;
      }

      return *this;
    }


    // AssemblyConnectionDescription
    ::XMLSchema::string<ACE_TCHAR> const& AssemblyConnectionDescription::
    name () const
    {
      return *name_;
    }

    void AssemblyConnectionDescription::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // AssemblyConnectionDescription
    AssemblyConnectionDescription::deployRequirement_iterator AssemblyConnectionDescription::
    begin_deployRequirement ()
    {
      return deployRequirement_.begin ();
    }

    AssemblyConnectionDescription::deployRequirement_iterator AssemblyConnectionDescription::
    end_deployRequirement ()
    {
      return deployRequirement_.end ();
    }

    AssemblyConnectionDescription::deployRequirement_const_iterator AssemblyConnectionDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.begin ();
    }

    AssemblyConnectionDescription::deployRequirement_const_iterator AssemblyConnectionDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.end ();
    }

    void AssemblyConnectionDescription::
    add_deployRequirement (AssemblyConnectionDescription::deployRequirement_value_type const& e)
    {
      deployRequirement_.push_back (e);
    }

    size_t AssemblyConnectionDescription::
    count_deployRequirement(void) const
    {
      return deployRequirement_.size ();
    }

    // AssemblyConnectionDescription
    AssemblyConnectionDescription::internalEndpoint_iterator AssemblyConnectionDescription::
    begin_internalEndpoint ()
    {
      return internalEndpoint_.begin ();
    }

    AssemblyConnectionDescription::internalEndpoint_iterator AssemblyConnectionDescription::
    end_internalEndpoint ()
    {
      return internalEndpoint_.end ();
    }

    AssemblyConnectionDescription::internalEndpoint_const_iterator AssemblyConnectionDescription::
    begin_internalEndpoint () const
    {
      return internalEndpoint_.begin ();
    }

    AssemblyConnectionDescription::internalEndpoint_const_iterator AssemblyConnectionDescription::
    end_internalEndpoint () const
    {
      return internalEndpoint_.end ();
    }

    void AssemblyConnectionDescription::
    add_internalEndpoint (AssemblyConnectionDescription::internalEndpoint_value_type const& e)
    {
      internalEndpoint_.push_back (e);
    }

    size_t AssemblyConnectionDescription::
    count_internalEndpoint(void) const
    {
      return internalEndpoint_.size ();
    }

    // AssemblyConnectionDescription
    AssemblyConnectionDescription::externalEndpoint_iterator AssemblyConnectionDescription::
    begin_externalEndpoint ()
    {
      return externalEndpoint_.begin ();
    }

    AssemblyConnectionDescription::externalEndpoint_iterator AssemblyConnectionDescription::
    end_externalEndpoint ()
    {
      return externalEndpoint_.end ();
    }

    AssemblyConnectionDescription::externalEndpoint_const_iterator AssemblyConnectionDescription::
    begin_externalEndpoint () const
    {
      return externalEndpoint_.begin ();
    }

    AssemblyConnectionDescription::externalEndpoint_const_iterator AssemblyConnectionDescription::
    end_externalEndpoint () const
    {
      return externalEndpoint_.end ();
    }

    void AssemblyConnectionDescription::
    add_externalEndpoint (AssemblyConnectionDescription::externalEndpoint_value_type const& e)
    {
      externalEndpoint_.push_back (e);
    }

    size_t AssemblyConnectionDescription::
    count_externalEndpoint(void) const
    {
      return externalEndpoint_.size ();
    }

    // AssemblyConnectionDescription
    AssemblyConnectionDescription::externalReference_iterator AssemblyConnectionDescription::
    begin_externalReference ()
    {
      return externalReference_.begin ();
    }

    AssemblyConnectionDescription::externalReference_iterator AssemblyConnectionDescription::
    end_externalReference ()
    {
      return externalReference_.end ();
    }

    AssemblyConnectionDescription::externalReference_const_iterator AssemblyConnectionDescription::
    begin_externalReference () const
    {
      return externalReference_.begin ();
    }

    AssemblyConnectionDescription::externalReference_const_iterator AssemblyConnectionDescription::
    end_externalReference () const
    {
      return externalReference_.end ();
    }

    void AssemblyConnectionDescription::
    add_externalReference (AssemblyConnectionDescription::externalReference_value_type const& e)
    {
      externalReference_.push_back (e);
    }

    size_t AssemblyConnectionDescription::
    count_externalReference(void) const
    {
      return externalReference_.size ();
    }


    // PlanLocalityKind

    PlanLocalityKind::Value PlanLocalityKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::PlanLocalityKind const& a, ::DAnCE::Config_Handlers::PlanLocalityKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::PlanLocalityKind const& a, ::DAnCE::Config_Handlers::PlanLocalityKind const& b)
    {
      return a.v_ != b.v_;
    }

    PlanLocalityKind::
    PlanLocalityKind (PlanLocalityKind::Value v)
    : v_ (v)
    {
    }

    // PlanLocality

    PlanLocality::PlanLocality (::DAnCE::Config_Handlers::PlanLocalityKind const& constraint__,
                                constrainedInstance_container_type const& constrainedInstance__)
    : ::XSCRT::Type ()
    , constraint_ (new ::DAnCE::Config_Handlers::PlanLocalityKind (constraint__))
    , constrainedInstance_ (constrainedInstance__)
    {
      constraint_->container (this);
    }

    PlanLocality::PlanLocality (PlanLocality const& s) :
    ::XSCRT::Type (s)
    , constraint_ (new ::DAnCE::Config_Handlers::PlanLocalityKind (*s.constraint_))
    , constrainedInstance_ (s.constrainedInstance_)
    {
      constraint_->container (this);
    }

    PlanLocality&
    PlanLocality::operator= (PlanLocality const& s)
    {
      if (&s != this)
      {
        constraint (*s.constraint_);

        constrainedInstance_ = s.constrainedInstance_;
      }

      return *this;
    }


    // PlanLocality
    ::DAnCE::Config_Handlers::PlanLocalityKind const& PlanLocality::
    constraint () const
    {
      return *constraint_;
    }

    void PlanLocality::
    constraint (::DAnCE::Config_Handlers::PlanLocalityKind const& e)
    {
      *constraint_ = e;
    }

    // PlanLocality
    PlanLocality::constrainedInstance_iterator PlanLocality::
    begin_constrainedInstance ()
    {
      return constrainedInstance_.begin ();
    }

    PlanLocality::constrainedInstance_iterator PlanLocality::
    end_constrainedInstance ()
    {
      return constrainedInstance_.end ();
    }

    PlanLocality::constrainedInstance_const_iterator PlanLocality::
    begin_constrainedInstance () const
    {
      return constrainedInstance_.begin ();
    }

    PlanLocality::constrainedInstance_const_iterator PlanLocality::
    end_constrainedInstance () const
    {
      return constrainedInstance_.end ();
    }

    void PlanLocality::
    add_constrainedInstance (PlanLocality::constrainedInstance_value_type const& e)
    {
      constrainedInstance_.push_back (e);
    }

    size_t PlanLocality::
    count_constrainedInstance(void) const
    {
      return constrainedInstance_.size ();
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    // IdRef

    IdRef::
    IdRef (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("href"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (a);
          href (t);
        }

        else if (n == ACE_TEXT ("idref"))
        {
          ::XMLSchema::IDREF<ACE_TCHAR> t (a);
          idref (t);
          std::basic_string<ACE_TCHAR> temp ((*idref_).id().c_str());

          (*ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance())->add_idref(temp, this);
        }

        else
        {
        }
      }
    }

    // TCKind

    TCKind::
    TCKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    : ::XSCRT::Type (e)
    {
      std::basic_string<ACE_TCHAR> v (e.value ());

      if (v == ACE_TEXT ("tk_null")) v_ = tk_null_l;
      else if (v == ACE_TEXT ("tk_void")) v_ = tk_void_l;
      else if (v == ACE_TEXT ("tk_short")) v_ = tk_short_l;
      else if (v == ACE_TEXT ("tk_long")) v_ = tk_long_l;
      else if (v == ACE_TEXT ("tk_ushort")) v_ = tk_ushort_l;
      else if (v == ACE_TEXT ("tk_ulong")) v_ = tk_ulong_l;
      else if (v == ACE_TEXT ("tk_float")) v_ = tk_float_l;
      else if (v == ACE_TEXT ("tk_double")) v_ = tk_double_l;
      else if (v == ACE_TEXT ("tk_boolean")) v_ = tk_boolean_l;
      else if (v == ACE_TEXT ("tk_char")) v_ = tk_char_l;
      else if (v == ACE_TEXT ("tk_octet")) v_ = tk_octet_l;
      else if (v == ACE_TEXT ("tk_any")) v_ = tk_any_l;
      else if (v == ACE_TEXT ("tk_TypeCode")) v_ = tk_TypeCode_l;
      else if (v == ACE_TEXT ("tk_Principal")) v_ = tk_Principal_l;
      else if (v == ACE_TEXT ("tk_objref")) v_ = tk_objref_l;
      else if (v == ACE_TEXT ("tk_struct")) v_ = tk_struct_l;
      else if (v == ACE_TEXT ("tk_union")) v_ = tk_union_l;
      else if (v == ACE_TEXT ("tk_enum")) v_ = tk_enum_l;
      else if (v == ACE_TEXT ("tk_string")) v_ = tk_string_l;
      else if (v == ACE_TEXT ("tk_sequence")) v_ = tk_sequence_l;
      else if (v == ACE_TEXT ("tk_array")) v_ = tk_array_l;
      else if (v == ACE_TEXT ("tk_alias")) v_ = tk_alias_l;
      else if (v == ACE_TEXT ("tk_except")) v_ = tk_except_l;
      else if (v == ACE_TEXT ("tk_longlong")) v_ = tk_longlong_l;
      else if (v == ACE_TEXT ("tk_ulonglong")) v_ = tk_ulonglong_l;
      else if (v == ACE_TEXT ("tk_longdouble")) v_ = tk_longdouble_l;
      else if (v == ACE_TEXT ("tk_wchar")) v_ = tk_wchar_l;
      else if (v == ACE_TEXT ("tk_wstring")) v_ = tk_wstring_l;
      else if (v == ACE_TEXT ("tk_fixed")) v_ = tk_fixed_l;
      else if (v == ACE_TEXT ("tk_value")) v_ = tk_value_l;
      else if (v == ACE_TEXT ("tk_value_box")) v_ = tk_value_box_l;
      else if (v == ACE_TEXT ("tk_native")) v_ = tk_native_l;
      else if (v == ACE_TEXT ("tk_abstract_interface")) v_ = tk_abstract_interface_l;
      else if (v == ACE_TEXT ("tk_local_interface")) v_ = tk_local_interface_l;
      else if (v == ACE_TEXT ("tk_component")) v_ = tk_component_l;
      else if (v == ACE_TEXT ("tk_home")) v_ = tk_home_l;
      else if (v == ACE_TEXT ("tk_event")) v_ = tk_event_l;
      else
      {
      }
    }

    TCKind::
    TCKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
    : ::XSCRT::Type (a)
    {
      std::basic_string<ACE_TCHAR> v (a.value ());

      if (v == ACE_TEXT ("tk_null")) v_ = tk_null_l;
      else if (v == ACE_TEXT ("tk_void")) v_ = tk_void_l;
      else if (v == ACE_TEXT ("tk_short")) v_ = tk_short_l;
      else if (v == ACE_TEXT ("tk_long")) v_ = tk_long_l;
      else if (v == ACE_TEXT ("tk_ushort")) v_ = tk_ushort_l;
      else if (v == ACE_TEXT ("tk_ulong")) v_ = tk_ulong_l;
      else if (v == ACE_TEXT ("tk_float")) v_ = tk_float_l;
      else if (v == ACE_TEXT ("tk_double")) v_ = tk_double_l;
      else if (v == ACE_TEXT ("tk_boolean")) v_ = tk_boolean_l;
      else if (v == ACE_TEXT ("tk_char")) v_ = tk_char_l;
      else if (v == ACE_TEXT ("tk_octet")) v_ = tk_octet_l;
      else if (v == ACE_TEXT ("tk_any")) v_ = tk_any_l;
      else if (v == ACE_TEXT ("tk_TypeCode")) v_ = tk_TypeCode_l;
      else if (v == ACE_TEXT ("tk_Principal")) v_ = tk_Principal_l;
      else if (v == ACE_TEXT ("tk_objref")) v_ = tk_objref_l;
      else if (v == ACE_TEXT ("tk_struct")) v_ = tk_struct_l;
      else if (v == ACE_TEXT ("tk_union")) v_ = tk_union_l;
      else if (v == ACE_TEXT ("tk_enum")) v_ = tk_enum_l;
      else if (v == ACE_TEXT ("tk_string")) v_ = tk_string_l;
      else if (v == ACE_TEXT ("tk_sequence")) v_ = tk_sequence_l;
      else if (v == ACE_TEXT ("tk_array")) v_ = tk_array_l;
      else if (v == ACE_TEXT ("tk_alias")) v_ = tk_alias_l;
      else if (v == ACE_TEXT ("tk_except")) v_ = tk_except_l;
      else if (v == ACE_TEXT ("tk_longlong")) v_ = tk_longlong_l;
      else if (v == ACE_TEXT ("tk_ulonglong")) v_ = tk_ulonglong_l;
      else if (v == ACE_TEXT ("tk_longdouble")) v_ = tk_longdouble_l;
      else if (v == ACE_TEXT ("tk_wchar")) v_ = tk_wchar_l;
      else if (v == ACE_TEXT ("tk_wstring")) v_ = tk_wstring_l;
      else if (v == ACE_TEXT ("tk_fixed")) v_ = tk_fixed_l;
      else if (v == ACE_TEXT ("tk_value")) v_ = tk_value_l;
      else if (v == ACE_TEXT ("tk_value_box")) v_ = tk_value_box_l;
      else if (v == ACE_TEXT ("tk_native")) v_ = tk_native_l;
      else if (v == ACE_TEXT ("tk_abstract_interface")) v_ = tk_abstract_interface_l;
      else if (v == ACE_TEXT ("tk_local_interface")) v_ = tk_local_interface_l;
      else if (v == ACE_TEXT ("tk_component")) v_ = tk_component_l;
      else if (v == ACE_TEXT ("tk_home")) v_ = tk_home_l;
      else if (v == ACE_TEXT ("tk_event")) v_ = tk_event_l;
      else
      {
      }
    }

    TCKind const TCKind::tk_null (TCKind::tk_null_l);
    TCKind const TCKind::tk_void (TCKind::tk_void_l);
    TCKind const TCKind::tk_short (TCKind::tk_short_l);
    TCKind const TCKind::tk_long (TCKind::tk_long_l);
    TCKind const TCKind::tk_ushort (TCKind::tk_ushort_l);
    TCKind const TCKind::tk_ulong (TCKind::tk_ulong_l);
    TCKind const TCKind::tk_float (TCKind::tk_float_l);
    TCKind const TCKind::tk_double (TCKind::tk_double_l);
    TCKind const TCKind::tk_boolean (TCKind::tk_boolean_l);
    TCKind const TCKind::tk_char (TCKind::tk_char_l);
    TCKind const TCKind::tk_octet (TCKind::tk_octet_l);
    TCKind const TCKind::tk_any (TCKind::tk_any_l);
    TCKind const TCKind::tk_TypeCode (TCKind::tk_TypeCode_l);
    TCKind const TCKind::tk_Principal (TCKind::tk_Principal_l);
    TCKind const TCKind::tk_objref (TCKind::tk_objref_l);
    TCKind const TCKind::tk_struct (TCKind::tk_struct_l);
    TCKind const TCKind::tk_union (TCKind::tk_union_l);
    TCKind const TCKind::tk_enum (TCKind::tk_enum_l);
    TCKind const TCKind::tk_string (TCKind::tk_string_l);
    TCKind const TCKind::tk_sequence (TCKind::tk_sequence_l);
    TCKind const TCKind::tk_array (TCKind::tk_array_l);
    TCKind const TCKind::tk_alias (TCKind::tk_alias_l);
    TCKind const TCKind::tk_except (TCKind::tk_except_l);
    TCKind const TCKind::tk_longlong (TCKind::tk_longlong_l);
    TCKind const TCKind::tk_ulonglong (TCKind::tk_ulonglong_l);
    TCKind const TCKind::tk_longdouble (TCKind::tk_longdouble_l);
    TCKind const TCKind::tk_wchar (TCKind::tk_wchar_l);
    TCKind const TCKind::tk_wstring (TCKind::tk_wstring_l);
    TCKind const TCKind::tk_fixed (TCKind::tk_fixed_l);
    TCKind const TCKind::tk_value (TCKind::tk_value_l);
    TCKind const TCKind::tk_value_box (TCKind::tk_value_box_l);
    TCKind const TCKind::tk_native (TCKind::tk_native_l);
    TCKind const TCKind::tk_abstract_interface (TCKind::tk_abstract_interface_l);
    TCKind const TCKind::tk_local_interface (TCKind::tk_local_interface_l);
    TCKind const TCKind::tk_component (TCKind::tk_component_l);
    TCKind const TCKind::tk_home (TCKind::tk_home_l);
    TCKind const TCKind::tk_event (TCKind::tk_event_l);

    // DataType

    DataType::
    DataType (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("kind"))
        {
          kind_ = DataType::kind_auto_ptr_type (new ::DAnCE::Config_Handlers::TCKind (e));
          kind_->container (this);
        }

        else if (n == ACE_TEXT("enum"))
        {
          ::DAnCE::Config_Handlers::EnumType t (e);
          enum_ (t);
        }

        else if (n == ACE_TEXT("struct"))
        {
          ::DAnCE::Config_Handlers::StructType t (e);
          struct_ (t);
        }

        else if (n == ACE_TEXT("value"))
        {
          ::DAnCE::Config_Handlers::ValueType t (e);
          value (t);
        }

        else if (n == ACE_TEXT("sequence"))
        {
          ::DAnCE::Config_Handlers::SequenceType t (e);
          sequence (t);
        }

        else if (n == ACE_TEXT("alias"))
        {
          ::DAnCE::Config_Handlers::AliasType t (e);
          alias (t);
        }

        else if (n == ACE_TEXT("array"))
        {
          ::DAnCE::Config_Handlers::ArrayType t (e);
          array (t);
        }

        else if (n == ACE_TEXT("boundedString"))
        {
          ::DAnCE::Config_Handlers::BoundedStringType t (e);
          boundedString (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("id"))
        {
          ::XMLSchema::ID<ACE_TCHAR> t (a);
          id (t);
          std::basic_string<ACE_TCHAR> temp ((*id_).c_str());
          (*ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance())->add_id(temp, this);
        }

        else
        {
        }
      }
    }

    // DataValue

    DataValue::
    DataValue (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("short"))
        {
          short_value_type t (new ::XMLSchema::short_ (e));
          add_short (t);
        }

        else if (n == ACE_TEXT("long"))
        {
          long_value_type t (new ::XMLSchema::int_ (e));
          add_long (t);
        }

        else if (n == ACE_TEXT("ushort"))
        {
          ushort_value_type t (new ::XMLSchema::unsignedShort (e));
          add_ushort (t);
        }

        else if (n == ACE_TEXT("ulong"))
        {
          ulong_value_type t (new ::XMLSchema::unsignedInt (e));
          add_ulong (t);
        }

        else if (n == ACE_TEXT("float"))
        {
          float_value_type t (new ::XMLSchema::float_ (e));
          add_float (t);
        }

        else if (n == ACE_TEXT("double"))
        {
          double_value_type t (new ::XMLSchema::double_ (e));
          add_double (t);
        }

        else if (n == ACE_TEXT("boolean"))
        {
          boolean_value_type t (new ::XMLSchema::boolean (e));
          add_boolean (t);
        }

        else if (n == ACE_TEXT("octet"))
        {
          octet_value_type t (new ::XMLSchema::unsignedByte (e));
          add_octet (t);
        }

        else if (n == ACE_TEXT("enum"))
        {
          enum_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_enum (t);
        }

        else if (n == ACE_TEXT("string"))
        {
          string_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_string (t);
        }

        else if (n == ACE_TEXT("longlong"))
        {
          longlong_value_type t (new ::XMLSchema::long_ (e));
          add_longlong (t);
        }

        else if (n == ACE_TEXT("ulonglong"))
        {
          ulonglong_value_type t (new ::XMLSchema::unsignedLong (e));
          add_ulonglong (t);
        }

        else if (n == ACE_TEXT("longdouble"))
        {
          longdouble_value_type t (new ::XMLSchema::double_ (e));
          add_longdouble (t);
        }

        else if (n == ACE_TEXT("element"))
        {
          element_value_type t (new ::DAnCE::Config_Handlers::DataValue (e));
          add_element (t);
        }

        else if (n == ACE_TEXT("member"))
        {
          member_value_type t (new ::DAnCE::Config_Handlers::NamedValue (e));
          add_member (t);
        }

        else
        {
        }
      }
    }

    // AliasType

    AliasType::
    AliasType (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = AliasType::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("typeId"))
        {
          typeId_ = AliasType::typeId_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          typeId_->container (this);
        }

        else if (n == ACE_TEXT("elementType"))
        {
          elementType_ = AliasType::elementType_auto_ptr_type (new ::DAnCE::Config_Handlers::DataType (e));
          elementType_->container (this);
        }

        else
        {
        }
      }
    }

    // EnumType

    EnumType::
    EnumType (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = EnumType::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("typeId"))
        {
          typeId_ = EnumType::typeId_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          typeId_->container (this);
        }

        else if (n == ACE_TEXT("member"))
        {
          member_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_member (t);
        }

        else
        {
        }
      }
    }

    // BoundedStringType

    BoundedStringType::
    BoundedStringType (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("bound"))
        {
          bound_value_type t (new ::XMLSchema::unsignedInt (e));
          add_bound (t);
        }

        else
        {
        }
      }
    }

    // StructType

    StructType::
    StructType (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = StructType::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("typeId"))
        {
          typeId_ = StructType::typeId_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          typeId_->container (this);
        }

        else if (n == ACE_TEXT("member"))
        {
          member_value_type t (new ::DAnCE::Config_Handlers::StructMemberType (e));
          add_member (t);
        }

        else
        {
        }
      }
    }

    // StructMemberType

    StructMemberType::
    StructMemberType (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = StructMemberType::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("type"))
        {
          type_ = StructMemberType::type_auto_ptr_type (new ::DAnCE::Config_Handlers::DataType (e));
          type_->container (this);
        }

        else
        {
        }
      }
    }

    // ValueType

    ValueType::
    ValueType (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ValueType::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("typeId"))
        {
          typeId_ = ValueType::typeId_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          typeId_->container (this);
        }

        else if (n == ACE_TEXT("modifier"))
        {
          modifier_ = ValueType::modifier_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          modifier_->container (this);
        }

        else if (n == ACE_TEXT("baseType"))
        {
          baseType_ = ValueType::baseType_auto_ptr_type (new ::DAnCE::Config_Handlers::DataType (e));
          baseType_->container (this);
        }

        else if (n == ACE_TEXT("member"))
        {
          member_value_type t (new ::DAnCE::Config_Handlers::ValueMemberType (e));
          add_member (t);
        }

        else
        {
        }
      }
    }

    // ValueMemberType

    ValueMemberType::
    ValueMemberType (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ValueMemberType::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("visibility"))
        {
          visibility_ = ValueMemberType::visibility_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          visibility_->container (this);
        }

        else if (n == ACE_TEXT("type"))
        {
          type_ = ValueMemberType::type_auto_ptr_type (new ::DAnCE::Config_Handlers::DataType (e));
          type_->container (this);
        }

        else
        {
        }
      }
    }

    // NamedValue

    NamedValue::
    NamedValue (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = NamedValue::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("value"))
        {
          value_ = NamedValue::value_auto_ptr_type (new ::DAnCE::Config_Handlers::DataValue (e));
          value_->container (this);
        }

        else
        {
        }
      }
    }

    // ArrayType

    ArrayType::
    ArrayType (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("length"))
        {
          length_ = ArrayType::length_auto_ptr_type (new ::XMLSchema::unsignedInt (e));
          length_->container (this);
        }

        else if (n == ACE_TEXT("elementType"))
        {
          elementType_ = ArrayType::elementType_auto_ptr_type (new ::DAnCE::Config_Handlers::DataType (e));
          elementType_->container (this);
        }

        else
        {
        }
      }
    }

    // SequenceType

    SequenceType::
    SequenceType (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("bound"))
        {
          ::XMLSchema::unsignedInt t (e);
          bound (t);
        }

        else if (n == ACE_TEXT("elementType"))
        {
          elementType_ = SequenceType::elementType_auto_ptr_type (new ::DAnCE::Config_Handlers::DataType (e));
          elementType_->container (this);
        }

        else
        {
        }
      }
    }

    // Any

    Any::
    Any (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("type"))
        {
          type_ = Any::type_auto_ptr_type (new ::DAnCE::Config_Handlers::DataType (e));
          type_->container (this);
        }

        else if (n == ACE_TEXT("value"))
        {
          value_ = Any::value_auto_ptr_type (new ::DAnCE::Config_Handlers::DataValue (e));
          value_->container (this);
        }

        else
        {
        }
      }
    }

    // Property

    Property::
    Property (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = Property::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("value"))
        {
          value_ = Property::value_auto_ptr_type (new ::DAnCE::Config_Handlers::Any (e));
          value_->container (this);
        }

        else
        {
        }
      }
    }

    // SatisfierPropertyKind

    SatisfierPropertyKind::
    SatisfierPropertyKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    : ::XSCRT::Type (e)
    {
      std::basic_string<ACE_TCHAR> v (e.value ());

      if (v == ACE_TEXT ("Quantity")) v_ = Quantity_l;
      else if (v == ACE_TEXT ("Capacity")) v_ = Capacity_l;
      else if (v == ACE_TEXT ("Minimum")) v_ = Minimum_l;
      else if (v == ACE_TEXT ("Maximum")) v_ = Maximum_l;
      else if (v == ACE_TEXT ("Attribute")) v_ = Attribute_l;
      else if (v == ACE_TEXT ("Selection")) v_ = Selection_l;
      else
      {
      }
    }

    SatisfierPropertyKind::
    SatisfierPropertyKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
    : ::XSCRT::Type (a)
    {
      std::basic_string<ACE_TCHAR> v (a.value ());

      if (v == ACE_TEXT ("Quantity")) v_ = Quantity_l;
      else if (v == ACE_TEXT ("Capacity")) v_ = Capacity_l;
      else if (v == ACE_TEXT ("Minimum")) v_ = Minimum_l;
      else if (v == ACE_TEXT ("Maximum")) v_ = Maximum_l;
      else if (v == ACE_TEXT ("Attribute")) v_ = Attribute_l;
      else if (v == ACE_TEXT ("Selection")) v_ = Selection_l;
      else
      {
      }
    }

    SatisfierPropertyKind const SatisfierPropertyKind::Quantity (SatisfierPropertyKind::Quantity_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Capacity (SatisfierPropertyKind::Capacity_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Minimum (SatisfierPropertyKind::Minimum_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Maximum (SatisfierPropertyKind::Maximum_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Attribute (SatisfierPropertyKind::Attribute_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Selection (SatisfierPropertyKind::Selection_l);

    // SatisfierProperty

    SatisfierProperty::
    SatisfierProperty (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = SatisfierProperty::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("kind"))
        {
          kind_ = SatisfierProperty::kind_auto_ptr_type (new ::DAnCE::Config_Handlers::SatisfierPropertyKind (e));
          kind_->container (this);
        }

        else if (n == ACE_TEXT("dynamic"))
        {
          dynamic_ = SatisfierProperty::dynamic_auto_ptr_type (new ::XMLSchema::boolean (e));
          dynamic_->container (this);
        }

        else if (n == ACE_TEXT("value"))
        {
          value_ = SatisfierProperty::value_auto_ptr_type (new ::DAnCE::Config_Handlers::Any (e));
          value_->container (this);
        }

        else
        {
        }
      }
    }

    // Resource

    Resource::
    Resource (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = Resource::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("resourceType"))
        {
          resourceType_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_resourceType (t);
        }

        else if (n == ACE_TEXT("property"))
        {
          property_value_type t (new ::DAnCE::Config_Handlers::SatisfierProperty (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // Requirement

    Requirement::
    Requirement (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = Requirement::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("resourceType"))
        {
          resourceType_ = Requirement::resourceType_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          resourceType_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          property_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // ResourceDeploymentDescription

    ResourceDeploymentDescription::
    ResourceDeploymentDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("requirementName"))
        {
          requirementName_ = ResourceDeploymentDescription::requirementName_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          requirementName_->container (this);
        }

        else if (n == ACE_TEXT("resourceName"))
        {
          resourceName_ = ResourceDeploymentDescription::resourceName_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          resourceName_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          property_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // ArtifactDeploymentDescription

    ArtifactDeploymentDescription::
    ArtifactDeploymentDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ArtifactDeploymentDescription::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("source"))
        {
          source_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_source (t);
        }

        else if (n == ACE_TEXT("node"))
        {
          node_ = ArtifactDeploymentDescription::node_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          node_->container (this);
        }

        else if (n == ACE_TEXT("location"))
        {
          location_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_location (t);
        }

        else if (n == ACE_TEXT("execParameter"))
        {
          execParameter_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_execParameter (t);
        }

        else if (n == ACE_TEXT("deployRequirement"))
        {
          deployRequirement_value_type t (new ::DAnCE::Config_Handlers::Requirement (e));
          add_deployRequirement (t);
        }

        else if (n == ACE_TEXT("deployedResource"))
        {
          deployedResource_value_type t (new ::DAnCE::Config_Handlers::ResourceDeploymentDescription (e));
          add_deployedResource (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("id"))
        {
          ::XMLSchema::ID<ACE_TCHAR> t (a);
          id (t);
          std::basic_string<ACE_TCHAR> temp ((*id_).c_str());
          (*ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance())->add_id(temp, this);
        }

        else
        {
        }
      }
    }

    // MonolithicDeploymentDescription

    MonolithicDeploymentDescription::
    MonolithicDeploymentDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = MonolithicDeploymentDescription::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("source"))
        {
          source_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_source (t);
        }

        else if (n == ACE_TEXT("artifact"))
        {
          artifact_value_type t (new ::DAnCE::Config_Handlers::IdRef (e));
          add_artifact (t);
        }

        else if (n == ACE_TEXT("execParameter"))
        {
          execParameter_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_execParameter (t);
        }

        else if (n == ACE_TEXT("deployRequirement"))
        {
          deployRequirement_value_type t (new ::DAnCE::Config_Handlers::Requirement (e));
          add_deployRequirement (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("id"))
        {
          ::XMLSchema::ID<ACE_TCHAR> t (a);
          id (t);
          std::basic_string<ACE_TCHAR> temp ((*id_).c_str());
          (*ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance())->add_id(temp, this);
        }

        else
        {
        }
      }
    }

    // ResourceUsageKind

    ResourceUsageKind::
    ResourceUsageKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    : ::XSCRT::Type (e)
    {
      std::basic_string<ACE_TCHAR> v (e.value ());

      if (v == ACE_TEXT ("None")) v_ = None_l;
      else if (v == ACE_TEXT ("InstanceUsesResource")) v_ = InstanceUsesResource_l;
      else if (v == ACE_TEXT ("ResourceUsesInstance")) v_ = ResourceUsesInstance_l;
      else if (v == ACE_TEXT ("PortUsesResource")) v_ = PortUsesResource_l;
      else if (v == ACE_TEXT ("ResourceUsesPort")) v_ = ResourceUsesPort_l;
      else
      {
      }
    }

    ResourceUsageKind::
    ResourceUsageKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
    : ::XSCRT::Type (a)
    {
      std::basic_string<ACE_TCHAR> v (a.value ());

      if (v == ACE_TEXT ("None")) v_ = None_l;
      else if (v == ACE_TEXT ("InstanceUsesResource")) v_ = InstanceUsesResource_l;
      else if (v == ACE_TEXT ("ResourceUsesInstance")) v_ = ResourceUsesInstance_l;
      else if (v == ACE_TEXT ("PortUsesResource")) v_ = PortUsesResource_l;
      else if (v == ACE_TEXT ("ResourceUsesPort")) v_ = ResourceUsesPort_l;
      else
      {
      }
    }

    ResourceUsageKind const ResourceUsageKind::None (ResourceUsageKind::None_l);
    ResourceUsageKind const ResourceUsageKind::InstanceUsesResource (ResourceUsageKind::InstanceUsesResource_l);
    ResourceUsageKind const ResourceUsageKind::ResourceUsesInstance (ResourceUsageKind::ResourceUsesInstance_l);
    ResourceUsageKind const ResourceUsageKind::PortUsesResource (ResourceUsageKind::PortUsesResource_l);
    ResourceUsageKind const ResourceUsageKind::ResourceUsesPort (ResourceUsageKind::ResourceUsesPort_l);

    // InstanceResourceDeploymentDescription

    InstanceResourceDeploymentDescription::
    InstanceResourceDeploymentDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("resourceUsage"))
        {
          resourceUsage_ = InstanceResourceDeploymentDescription::resourceUsage_auto_ptr_type (new ::DAnCE::Config_Handlers::ResourceUsageKind (e));
          resourceUsage_->container (this);
        }

        else if (n == ACE_TEXT("requirementName"))
        {
          requirementName_ = InstanceResourceDeploymentDescription::requirementName_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          requirementName_->container (this);
        }

        else if (n == ACE_TEXT("resourceName"))
        {
          resourceName_ = InstanceResourceDeploymentDescription::resourceName_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          resourceName_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          property_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // InstanceDeploymentDescription

    InstanceDeploymentDescription::
    InstanceDeploymentDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = InstanceDeploymentDescription::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("node"))
        {
          node_ = InstanceDeploymentDescription::node_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          node_->container (this);
        }

        else if (n == ACE_TEXT("source"))
        {
          source_ = InstanceDeploymentDescription::source_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          source_->container (this);
        }

        else if (n == ACE_TEXT("implementation"))
        {
          implementation_ = InstanceDeploymentDescription::implementation_auto_ptr_type (new ::DAnCE::Config_Handlers::IdRef (e));
          implementation_->container (this);
        }

        else if (n == ACE_TEXT("configProperty"))
        {
          configProperty_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_configProperty (t);
        }

        else if (n == ACE_TEXT("deployedResource"))
        {
          deployedResource_value_type t (new ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription (e));
          add_deployedResource (t);
        }

        else if (n == ACE_TEXT("deployedSharedResource"))
        {
          ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription t (e);
          deployedSharedResource (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("id"))
        {
          ::XMLSchema::ID<ACE_TCHAR> t (a);
          id (t);
          std::basic_string<ACE_TCHAR> temp ((*id_).c_str());
          (*ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance())->add_id(temp, this);
        }

        else
        {
        }
      }
    }

    // CCMComponentPortKind

    CCMComponentPortKind::
    CCMComponentPortKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    : ::XSCRT::Type (e)
    {
      std::basic_string<ACE_TCHAR> v (e.value ());

      if (v == ACE_TEXT ("Facet")) v_ = Facet_l;
      else if (v == ACE_TEXT ("SimplexReceptacle")) v_ = SimplexReceptacle_l;
      else if (v == ACE_TEXT ("MultiplexReceptacle")) v_ = MultiplexReceptacle_l;
      else if (v == ACE_TEXT ("EventEmitter")) v_ = EventEmitter_l;
      else if (v == ACE_TEXT ("EventPublisher")) v_ = EventPublisher_l;
      else if (v == ACE_TEXT ("EventConsumer")) v_ = EventConsumer_l;
      else if (v == ACE_TEXT ("ExtendedPort")) v_ = ExtendedPort_l;
      else if (v == ACE_TEXT ("MirrorPort")) v_ = MirrorPort_l;
      else
      {
      }
    }

    CCMComponentPortKind::
    CCMComponentPortKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
    : ::XSCRT::Type (a)
    {
      std::basic_string<ACE_TCHAR> v (a.value ());

      if (v == ACE_TEXT ("Facet")) v_ = Facet_l;
      else if (v == ACE_TEXT ("SimplexReceptacle")) v_ = SimplexReceptacle_l;
      else if (v == ACE_TEXT ("MultiplexReceptacle")) v_ = MultiplexReceptacle_l;
      else if (v == ACE_TEXT ("EventEmitter")) v_ = EventEmitter_l;
      else if (v == ACE_TEXT ("EventPublisher")) v_ = EventPublisher_l;
      else if (v == ACE_TEXT ("EventConsumer")) v_ = EventConsumer_l;
      else if (v == ACE_TEXT ("ExtendedPort")) v_ = ExtendedPort_l;
      else if (v == ACE_TEXT ("MirrorPort")) v_ = MirrorPort_l;
      else
      {
      }
    }

    CCMComponentPortKind const CCMComponentPortKind::Facet (CCMComponentPortKind::Facet_l);
    CCMComponentPortKind const CCMComponentPortKind::SimplexReceptacle (CCMComponentPortKind::SimplexReceptacle_l);
    CCMComponentPortKind const CCMComponentPortKind::MultiplexReceptacle (CCMComponentPortKind::MultiplexReceptacle_l);
    CCMComponentPortKind const CCMComponentPortKind::EventEmitter (CCMComponentPortKind::EventEmitter_l);
    CCMComponentPortKind const CCMComponentPortKind::EventPublisher (CCMComponentPortKind::EventPublisher_l);
    CCMComponentPortKind const CCMComponentPortKind::EventConsumer (CCMComponentPortKind::EventConsumer_l);
    CCMComponentPortKind const CCMComponentPortKind::ExtendedPort (CCMComponentPortKind::ExtendedPort_l);
    CCMComponentPortKind const CCMComponentPortKind::MirrorPort (CCMComponentPortKind::MirrorPort_l);

    // ComponentPortDescription

    ComponentPortDescription::
    ComponentPortDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ComponentPortDescription::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("specificType"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          specificType (t);
        }

        else if (n == ACE_TEXT("supportedType"))
        {
          supportedType_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_supportedType (t);
        }

        else if (n == ACE_TEXT("provider"))
        {
          provider_ = ComponentPortDescription::provider_auto_ptr_type (new ::XMLSchema::boolean (e));
          provider_->container (this);
        }

        else if (n == ACE_TEXT("exclusiveProvider"))
        {
          exclusiveProvider_ = ComponentPortDescription::exclusiveProvider_auto_ptr_type (new ::XMLSchema::boolean (e));
          exclusiveProvider_->container (this);
        }

        else if (n == ACE_TEXT("exclusiveUser"))
        {
          exclusiveUser_ = ComponentPortDescription::exclusiveUser_auto_ptr_type (new ::XMLSchema::boolean (e));
          exclusiveUser_->container (this);
        }

        else if (n == ACE_TEXT("optional"))
        {
          optional_ = ComponentPortDescription::optional_auto_ptr_type (new ::XMLSchema::boolean (e));
          optional_->container (this);
        }

        else if (n == ACE_TEXT("kind"))
        {
          kind_ = ComponentPortDescription::kind_auto_ptr_type (new ::DAnCE::Config_Handlers::CCMComponentPortKind (e));
          kind_->container (this);
        }

        else if (n == ACE_TEXT("templateParam"))
        {
          templateParam_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_templateParam (t);
        }

        else
        {
        }
      }
    }

    // ComponentPropertyDescription

    ComponentPropertyDescription::
    ComponentPropertyDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ComponentPropertyDescription::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("type"))
        {
          type_ = ComponentPropertyDescription::type_auto_ptr_type (new ::DAnCE::Config_Handlers::DataType (e));
          type_->container (this);
        }

        else
        {
        }
      }
    }

    // ComponentExternalPortEndpoint

    ComponentExternalPortEndpoint::
    ComponentExternalPortEndpoint (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("portName"))
        {
          portName_ = ComponentExternalPortEndpoint::portName_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          portName_->container (this);
        }

        else
        {
        }
      }
    }

    // PlanSubcomponentPortEndpoint

    PlanSubcomponentPortEndpoint::
    PlanSubcomponentPortEndpoint (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("portName"))
        {
          portName_ = PlanSubcomponentPortEndpoint::portName_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          portName_->container (this);
        }

        else if (n == ACE_TEXT("provider"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          provider (t);
        }

        else if (n == ACE_TEXT("kind"))
        {
          kind_ = PlanSubcomponentPortEndpoint::kind_auto_ptr_type (new ::DAnCE::Config_Handlers::CCMComponentPortKind (e));
          kind_->container (this);
        }

        else if (n == ACE_TEXT("instance"))
        {
          instance_ = PlanSubcomponentPortEndpoint::instance_auto_ptr_type (new ::DAnCE::Config_Handlers::IdRef (e));
          instance_->container (this);
        }

        else
        {
        }
      }
    }

    // ExternalReferenceEndpoint

    ExternalReferenceEndpoint::
    ExternalReferenceEndpoint (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("location"))
        {
          location_ = ExternalReferenceEndpoint::location_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          location_->container (this);
        }

        else if (n == ACE_TEXT("provider"))
        {
          provider_ = ExternalReferenceEndpoint::provider_auto_ptr_type (new ::XMLSchema::boolean (e));
          provider_->container (this);
        }

        else if (n == ACE_TEXT("portName"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          portName (t);
        }

        else if (n == ACE_TEXT("supportedType"))
        {
          supportedType_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_supportedType (t);
        }

        else
        {
        }
      }
    }

    // ConnectionResourceDeploymentDescription

    ConnectionResourceDeploymentDescription::
    ConnectionResourceDeploymentDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("targetName"))
        {
          targetName_ = ConnectionResourceDeploymentDescription::targetName_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          targetName_->container (this);
        }

        else if (n == ACE_TEXT("requirementName"))
        {
          requirementName_ = ConnectionResourceDeploymentDescription::requirementName_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          requirementName_->container (this);
        }

        else if (n == ACE_TEXT("resourceName"))
        {
          resourceName_ = ConnectionResourceDeploymentDescription::resourceName_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          resourceName_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          property_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // PlanConnectionDescription

    PlanConnectionDescription::
    PlanConnectionDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = PlanConnectionDescription::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("source"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          source (t);
        }

        else if (n == ACE_TEXT("deployRequirement"))
        {
          deployRequirement_value_type t (new ::DAnCE::Config_Handlers::Requirement (e));
          add_deployRequirement (t);
        }

        else if (n == ACE_TEXT("externalEndpoint"))
        {
          externalEndpoint_value_type t (new ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint (e));
          add_externalEndpoint (t);
        }

        else if (n == ACE_TEXT("internalEndpoint"))
        {
          internalEndpoint_value_type t (new ::DAnCE::Config_Handlers::PlanSubcomponentPortEndpoint (e));
          add_internalEndpoint (t);
        }

        else if (n == ACE_TEXT("externalReference"))
        {
          externalReference_value_type t (new ::DAnCE::Config_Handlers::ExternalReferenceEndpoint (e));
          add_externalReference (t);
        }

        else if (n == ACE_TEXT("deployedResource"))
        {
          deployedResource_value_type t (new ::DAnCE::Config_Handlers::ConnectionResourceDeploymentDescription (e));
          add_deployedResource (t);
        }

        else
        {
        }
      }
    }

    // ImplementationDependency

    ImplementationDependency::
    ImplementationDependency (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("requiredType"))
        {
          requiredType_ = ImplementationDependency::requiredType_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          requiredType_->container (this);
        }

        else
        {
        }
      }
    }

    // Capability

    Capability::
    Capability (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = Capability::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("resourceType"))
        {
          resourceType_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_resourceType (t);
        }

        else if (n == ACE_TEXT("property"))
        {
          property_value_type t (new ::DAnCE::Config_Handlers::SatisfierProperty (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // ImplementationRequirement

    ImplementationRequirement::
    ImplementationRequirement (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("resourceUsage"))
        {
          ::DAnCE::Config_Handlers::ResourceUsageKind t (e);
          resourceUsage (t);
        }

        else if (n == ACE_TEXT("resourcePort"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          resourcePort (t);
        }

        else if (n == ACE_TEXT("componentPort"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          componentPort (t);
        }

        else if (n == ACE_TEXT("resourceType"))
        {
          resourceType_ = ImplementationRequirement::resourceType_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          resourceType_->container (this);
        }

        else if (n == ACE_TEXT("name"))
        {
          name_ = ImplementationRequirement::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          property_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // SubcomponentPortEndpoint

    SubcomponentPortEndpoint::
    SubcomponentPortEndpoint (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("portName"))
        {
          portName_ = SubcomponentPortEndpoint::portName_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          portName_->container (this);
        }

        else if (n == ACE_TEXT("instance"))
        {
          instance_ = SubcomponentPortEndpoint::instance_auto_ptr_type (new ::DAnCE::Config_Handlers::IdRef (e));
          instance_->container (this);
        }

        else
        {
        }
      }
    }

    // AssemblyConnectionDescription

    AssemblyConnectionDescription::
    AssemblyConnectionDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = AssemblyConnectionDescription::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("deployRequirement"))
        {
          deployRequirement_value_type t (new ::DAnCE::Config_Handlers::Requirement (e));
          add_deployRequirement (t);
        }

        else if (n == ACE_TEXT("internalEndpoint"))
        {
          internalEndpoint_value_type t (new ::DAnCE::Config_Handlers::SubcomponentPortEndpoint (e));
          add_internalEndpoint (t);
        }

        else if (n == ACE_TEXT("externalEndpoint"))
        {
          externalEndpoint_value_type t (new ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint (e));
          add_externalEndpoint (t);
        }

        else if (n == ACE_TEXT("externalReference"))
        {
          externalReference_value_type t (new ::DAnCE::Config_Handlers::ExternalReferenceEndpoint (e));
          add_externalReference (t);
        }

        else
        {
        }
      }
    }

    // PlanLocalityKind

    PlanLocalityKind::
    PlanLocalityKind (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    : ::XSCRT::Type (e)
    {
      std::basic_string<ACE_TCHAR> v (e.value ());

      if (v == ACE_TEXT ("SameProcess")) v_ = SameProcess_l;
      else if (v == ACE_TEXT ("DifferentProcess")) v_ = DifferentProcess_l;
      else if (v == ACE_TEXT ("NoConstraint")) v_ = NoConstraint_l;
      else
      {
      }
    }

    PlanLocalityKind::
    PlanLocalityKind (::XSCRT::XML::Attribute<ACE_TCHAR> const& a)
    : ::XSCRT::Type (a)
    {
      std::basic_string<ACE_TCHAR> v (a.value ());

      if (v == ACE_TEXT ("SameProcess")) v_ = SameProcess_l;
      else if (v == ACE_TEXT ("DifferentProcess")) v_ = DifferentProcess_l;
      else if (v == ACE_TEXT ("NoConstraint")) v_ = NoConstraint_l;
      else
      {
      }
    }

    PlanLocalityKind const PlanLocalityKind::SameProcess (PlanLocalityKind::SameProcess_l);
    PlanLocalityKind const PlanLocalityKind::DifferentProcess (PlanLocalityKind::DifferentProcess_l);
    PlanLocalityKind const PlanLocalityKind::NoConstraint (PlanLocalityKind::NoConstraint_l);

    // PlanLocality

    PlanLocality::
    PlanLocality (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("constraint"))
        {
          constraint_ = PlanLocality::constraint_auto_ptr_type (new ::DAnCE::Config_Handlers::PlanLocalityKind (e));
          constraint_->container (this);
        }

        else if (n == ACE_TEXT("constrainedInstance"))
        {
          constrainedInstance_value_type t (new ::DAnCE::Config_Handlers::IdRef (e));
          add_constrainedInstance (t);
        }

        else
        {
        }
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

