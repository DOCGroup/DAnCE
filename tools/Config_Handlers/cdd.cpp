/*
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please report this to the XSC project at
 * https://github.com/DOCGroup/XSC
 */
#include "cdd.hpp"

#include "ace/ace_wchar.h"
#include "ace/Null_Mutex.h"
#include "ace/TSS_T.h"
#include "ace/Singleton.h"

namespace DAnCE
{
  namespace Config_Handlers
  {
    // Domain

    Domain::Domain (node_container_type const& node__)
    : ::XSCRT::Type ()
    , node_ (node__)
    {
    }

    Domain::Domain (Domain const& s) :
    ::XSCRT::Type (s)
    , UUID_ (s.UUID_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.UUID_) : 0)
    , label_ (s.label_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.label_) : 0)
    , node_ (s.node_)
    , interconnect_ (s.interconnect_)
    , bridge_ (s.bridge_)
    , sharedResource_ (s.sharedResource_)
    , infoProperty_ (s.infoProperty_)
    {
      if (UUID_.get ()) UUID_->container (this);
      if (label_.get ()) label_->container (this);
    }

    Domain&
    Domain::operator= (Domain const& s)
    {
      if (&s != this)
      {
        if (s.UUID_.get ())
          UUID (*(s.UUID_));
        else
          UUID_.reset (0);

        if (s.label_.get ())
          label (*(s.label_));
        else
          label_.reset (0);

        node_ = s.node_;

        interconnect_ = s.interconnect_;

        bridge_ = s.bridge_;

        sharedResource_ = s.sharedResource_;

        infoProperty_ = s.infoProperty_;
      }

      return *this;
    }


    // Domain
    bool Domain::
    UUID_p () const
    {
      return UUID_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& Domain::
    UUID () const
    {
      return *UUID_;
    }

    void Domain::
    UUID (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (UUID_.get ())
      {
        *UUID_ = e;
      }

      else
      {
        UUID_ = Domain::UUID_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        UUID_->container (this);
      }
    }

    // Domain
    bool Domain::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& Domain::
    label () const
    {
      return *label_;
    }

    void Domain::
    label (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = Domain::label_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        label_->container (this);
      }
    }

    // Domain
    Domain::node_iterator Domain::
    begin_node ()
    {
      return node_.begin ();
    }

    Domain::node_iterator Domain::
    end_node ()
    {
      return node_.end ();
    }

    Domain::node_const_iterator Domain::
    begin_node () const
    {
      return node_.begin ();
    }

    Domain::node_const_iterator Domain::
    end_node () const
    {
      return node_.end ();
    }

    void Domain::
    add_node (Domain::node_value_type const& e)
    {
      node_.push_back (e);
    }

    size_t Domain::
    count_node(void) const
    {
      return node_.size ();
    }

    // Domain
    Domain::interconnect_iterator Domain::
    begin_interconnect ()
    {
      return interconnect_.begin ();
    }

    Domain::interconnect_iterator Domain::
    end_interconnect ()
    {
      return interconnect_.end ();
    }

    Domain::interconnect_const_iterator Domain::
    begin_interconnect () const
    {
      return interconnect_.begin ();
    }

    Domain::interconnect_const_iterator Domain::
    end_interconnect () const
    {
      return interconnect_.end ();
    }

    void Domain::
    add_interconnect (Domain::interconnect_value_type const& e)
    {
      interconnect_.push_back (e);
    }

    size_t Domain::
    count_interconnect(void) const
    {
      return interconnect_.size ();
    }

    // Domain
    Domain::bridge_iterator Domain::
    begin_bridge ()
    {
      return bridge_.begin ();
    }

    Domain::bridge_iterator Domain::
    end_bridge ()
    {
      return bridge_.end ();
    }

    Domain::bridge_const_iterator Domain::
    begin_bridge () const
    {
      return bridge_.begin ();
    }

    Domain::bridge_const_iterator Domain::
    end_bridge () const
    {
      return bridge_.end ();
    }

    void Domain::
    add_bridge (Domain::bridge_value_type const& e)
    {
      bridge_.push_back (e);
    }

    size_t Domain::
    count_bridge(void) const
    {
      return bridge_.size ();
    }

    // Domain
    Domain::sharedResource_iterator Domain::
    begin_sharedResource ()
    {
      return sharedResource_.begin ();
    }

    Domain::sharedResource_iterator Domain::
    end_sharedResource ()
    {
      return sharedResource_.end ();
    }

    Domain::sharedResource_const_iterator Domain::
    begin_sharedResource () const
    {
      return sharedResource_.begin ();
    }

    Domain::sharedResource_const_iterator Domain::
    end_sharedResource () const
    {
      return sharedResource_.end ();
    }

    void Domain::
    add_sharedResource (Domain::sharedResource_value_type const& e)
    {
      sharedResource_.push_back (e);
    }

    size_t Domain::
    count_sharedResource(void) const
    {
      return sharedResource_.size ();
    }

    // Domain
    Domain::infoProperty_iterator Domain::
    begin_infoProperty ()
    {
      return infoProperty_.begin ();
    }

    Domain::infoProperty_iterator Domain::
    end_infoProperty ()
    {
      return infoProperty_.end ();
    }

    Domain::infoProperty_const_iterator Domain::
    begin_infoProperty () const
    {
      return infoProperty_.begin ();
    }

    Domain::infoProperty_const_iterator Domain::
    end_infoProperty () const
    {
      return infoProperty_.end ();
    }

    void Domain::
    add_infoProperty (Domain::infoProperty_value_type const& e)
    {
      infoProperty_.push_back (e);
    }

    size_t Domain::
    count_infoProperty(void) const
    {
      return infoProperty_.size ();
    }


    // Bridge

    Bridge::Bridge (::XMLSchema::string<ACE_TCHAR> const& name__,
                    connect_container_type const& connect__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , connect_ (connect__)
    {
      name_->container (this);
    }

    Bridge::Bridge (Bridge const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , label_ (s.label_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.label_) : 0)
    , connect_ (s.connect_)
    , resource_ (s.resource_)
    {
      name_->container (this);
      if (label_.get ()) label_->container (this);
    }

    Bridge&
    Bridge::operator= (Bridge const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        if (s.label_.get ())
          label (*(s.label_));
        else
          label_.reset (0);

        connect_ = s.connect_;

        resource_ = s.resource_;
      }

      return *this;
    }


    // Bridge
    ::XMLSchema::string<ACE_TCHAR> const& Bridge::
    name () const
    {
      return *name_;
    }

    void Bridge::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // Bridge
    bool Bridge::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& Bridge::
    label () const
    {
      return *label_;
    }

    void Bridge::
    label (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = Bridge::label_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        label_->container (this);
      }
    }

    // Bridge
    Bridge::connect_iterator Bridge::
    begin_connect ()
    {
      return connect_.begin ();
    }

    Bridge::connect_iterator Bridge::
    end_connect ()
    {
      return connect_.end ();
    }

    Bridge::connect_const_iterator Bridge::
    begin_connect () const
    {
      return connect_.begin ();
    }

    Bridge::connect_const_iterator Bridge::
    end_connect () const
    {
      return connect_.end ();
    }

    void Bridge::
    add_connect (Bridge::connect_value_type const& e)
    {
      connect_.push_back (e);
    }

    size_t Bridge::
    count_connect(void) const
    {
      return connect_.size ();
    }

    // Bridge
    Bridge::resource_iterator Bridge::
    begin_resource ()
    {
      return resource_.begin ();
    }

    Bridge::resource_iterator Bridge::
    end_resource ()
    {
      return resource_.end ();
    }

    Bridge::resource_const_iterator Bridge::
    begin_resource () const
    {
      return resource_.begin ();
    }

    Bridge::resource_const_iterator Bridge::
    end_resource () const
    {
      return resource_.end ();
    }

    void Bridge::
    add_resource (Bridge::resource_value_type const& e)
    {
      resource_.push_back (e);
    }

    size_t Bridge::
    count_resource(void) const
    {
      return resource_.size ();
    }


    // Interconnect

    Interconnect::Interconnect (::XMLSchema::string<ACE_TCHAR> const& name__,
                                connect_container_type const& connect__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , connect_ (connect__)
    {
      name_->container (this);
    }

    Interconnect::Interconnect (Interconnect const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , label_ (s.label_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.label_) : 0)
    , connection_ (s.connection_)
    , connect_ (s.connect_)
    , resource_ (s.resource_)
    {
      name_->container (this);
      if (label_.get ()) label_->container (this);
    }

    Interconnect&
    Interconnect::operator= (Interconnect const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        if (s.label_.get ())
          label (*(s.label_));
        else
          label_.reset (0);

        connection_ = s.connection_;

        connect_ = s.connect_;

        resource_ = s.resource_;
      }

      return *this;
    }


    // Interconnect
    ::XMLSchema::string<ACE_TCHAR> const& Interconnect::
    name () const
    {
      return *name_;
    }

    void Interconnect::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // Interconnect
    bool Interconnect::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& Interconnect::
    label () const
    {
      return *label_;
    }

    void Interconnect::
    label (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = Interconnect::label_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        label_->container (this);
      }
    }

    // Interconnect
    Interconnect::connection_iterator Interconnect::
    begin_connection ()
    {
      return connection_.begin ();
    }

    Interconnect::connection_iterator Interconnect::
    end_connection ()
    {
      return connection_.end ();
    }

    Interconnect::connection_const_iterator Interconnect::
    begin_connection () const
    {
      return connection_.begin ();
    }

    Interconnect::connection_const_iterator Interconnect::
    end_connection () const
    {
      return connection_.end ();
    }

    void Interconnect::
    add_connection (Interconnect::connection_value_type const& e)
    {
      connection_.push_back (e);
    }

    size_t Interconnect::
    count_connection(void) const
    {
      return connection_.size ();
    }

    // Interconnect
    Interconnect::connect_iterator Interconnect::
    begin_connect ()
    {
      return connect_.begin ();
    }

    Interconnect::connect_iterator Interconnect::
    end_connect ()
    {
      return connect_.end ();
    }

    Interconnect::connect_const_iterator Interconnect::
    begin_connect () const
    {
      return connect_.begin ();
    }

    Interconnect::connect_const_iterator Interconnect::
    end_connect () const
    {
      return connect_.end ();
    }

    void Interconnect::
    add_connect (Interconnect::connect_value_type const& e)
    {
      connect_.push_back (e);
    }

    size_t Interconnect::
    count_connect(void) const
    {
      return connect_.size ();
    }

    // Interconnect
    Interconnect::resource_iterator Interconnect::
    begin_resource ()
    {
      return resource_.begin ();
    }

    Interconnect::resource_iterator Interconnect::
    end_resource ()
    {
      return resource_.end ();
    }

    Interconnect::resource_const_iterator Interconnect::
    begin_resource () const
    {
      return resource_.begin ();
    }

    Interconnect::resource_const_iterator Interconnect::
    end_resource () const
    {
      return resource_.end ();
    }

    void Interconnect::
    add_resource (Interconnect::resource_value_type const& e)
    {
      resource_.push_back (e);
    }

    size_t Interconnect::
    count_resource(void) const
    {
      return resource_.size ();
    }


    // Node

    Node::Node (::XMLSchema::string<ACE_TCHAR> const& name__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    {
      name_->container (this);
    }

    Node::Node (Node const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , label_ (s.label_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.label_) : 0)
    , connection_ (s.connection_)
    , sharedResource_ (s.sharedResource_)
    , resource_ (s.resource_)
    {
      name_->container (this);
      if (label_.get ()) label_->container (this);
    }

    Node&
    Node::operator= (Node const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        if (s.label_.get ())
          label (*(s.label_));
        else
          label_.reset (0);

        connection_ = s.connection_;

        sharedResource_ = s.sharedResource_;

        resource_ = s.resource_;
      }

      return *this;
    }


    // Node
    ::XMLSchema::string<ACE_TCHAR> const& Node::
    name () const
    {
      return *name_;
    }

    void Node::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // Node
    bool Node::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& Node::
    label () const
    {
      return *label_;
    }

    void Node::
    label (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = Node::label_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        label_->container (this);
      }
    }

    // Node
    Node::connection_iterator Node::
    begin_connection ()
    {
      return connection_.begin ();
    }

    Node::connection_iterator Node::
    end_connection ()
    {
      return connection_.end ();
    }

    Node::connection_const_iterator Node::
    begin_connection () const
    {
      return connection_.begin ();
    }

    Node::connection_const_iterator Node::
    end_connection () const
    {
      return connection_.end ();
    }

    void Node::
    add_connection (Node::connection_value_type const& e)
    {
      connection_.push_back (e);
    }

    size_t Node::
    count_connection(void) const
    {
      return connection_.size ();
    }

    // Node
    Node::sharedResource_iterator Node::
    begin_sharedResource ()
    {
      return sharedResource_.begin ();
    }

    Node::sharedResource_iterator Node::
    end_sharedResource ()
    {
      return sharedResource_.end ();
    }

    Node::sharedResource_const_iterator Node::
    begin_sharedResource () const
    {
      return sharedResource_.begin ();
    }

    Node::sharedResource_const_iterator Node::
    end_sharedResource () const
    {
      return sharedResource_.end ();
    }

    void Node::
    add_sharedResource (Node::sharedResource_value_type const& e)
    {
      sharedResource_.push_back (e);
    }

    size_t Node::
    count_sharedResource(void) const
    {
      return sharedResource_.size ();
    }

    // Node
    Node::resource_iterator Node::
    begin_resource ()
    {
      return resource_.begin ();
    }

    Node::resource_iterator Node::
    end_resource ()
    {
      return resource_.end ();
    }

    Node::resource_const_iterator Node::
    begin_resource () const
    {
      return resource_.begin ();
    }

    Node::resource_const_iterator Node::
    end_resource () const
    {
      return resource_.end ();
    }

    void Node::
    add_resource (Node::resource_value_type const& e)
    {
      resource_.push_back (e);
    }

    size_t Node::
    count_resource(void) const
    {
      return resource_.size ();
    }


    // SharedResource

    SharedResource::SharedResource (::XMLSchema::string<ACE_TCHAR> const& name__,
                                    ::XMLSchema::string<ACE_TCHAR> const& resourceType__,
                                    ::DAnCE::Config_Handlers::Node const& node__,
                                    ::DAnCE::Config_Handlers::SatisfierProperty const& property__)
    : ::XSCRT::Type ()
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (name__))
    , resourceType_ (new ::XMLSchema::string<ACE_TCHAR> (resourceType__))
    , node_ (new ::DAnCE::Config_Handlers::Node (node__))
    , property_ (new ::DAnCE::Config_Handlers::SatisfierProperty (property__))
    {
      name_->container (this);
      resourceType_->container (this);
      node_->container (this);
      property_->container (this);
    }

    SharedResource::SharedResource (SharedResource const& s) :
    ::XSCRT::Type (s)
    , name_ (new ::XMLSchema::string<ACE_TCHAR> (*s.name_))
    , resourceType_ (new ::XMLSchema::string<ACE_TCHAR> (*s.resourceType_))
    , node_ (new ::DAnCE::Config_Handlers::Node (*s.node_))
    , property_ (new ::DAnCE::Config_Handlers::SatisfierProperty (*s.property_))
    {
      name_->container (this);
      resourceType_->container (this);
      node_->container (this);
      property_->container (this);
    }

    SharedResource&
    SharedResource::operator= (SharedResource const& s)
    {
      if (&s != this)
      {
        name (*s.name_);

        resourceType (*s.resourceType_);

        node (*s.node_);

        property (*s.property_);
      }

      return *this;
    }


    // SharedResource
    ::XMLSchema::string<ACE_TCHAR> const& SharedResource::
    name () const
    {
      return *name_;
    }

    void SharedResource::
    name (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *name_ = e;
    }

    // SharedResource
    ::XMLSchema::string<ACE_TCHAR> const& SharedResource::
    resourceType () const
    {
      return *resourceType_;
    }

    void SharedResource::
    resourceType (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      *resourceType_ = e;
    }

    // SharedResource
    ::DAnCE::Config_Handlers::Node const& SharedResource::
    node () const
    {
      return *node_;
    }

    void SharedResource::
    node (::DAnCE::Config_Handlers::Node const& e)
    {
      *node_ = e;
    }

    // SharedResource
    ::DAnCE::Config_Handlers::SatisfierProperty const& SharedResource::
    property () const
    {
      return *property_;
    }

    void SharedResource::
    property (::DAnCE::Config_Handlers::SatisfierProperty const& e)
    {
      *property_ = e;
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    // Domain

    Domain::
    Domain (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("UUID"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          UUID (t);
        }

        else if (n == ACE_TEXT("label"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          label (t);
        }

        else if (n == ACE_TEXT("node"))
        {
          node_value_type t (new ::DAnCE::Config_Handlers::Node (e));
          add_node (t);
        }

        else if (n == ACE_TEXT("interconnect"))
        {
          interconnect_value_type t (new ::DAnCE::Config_Handlers::Interconnect (e));
          add_interconnect (t);
        }

        else if (n == ACE_TEXT("bridge"))
        {
          bridge_value_type t (new ::DAnCE::Config_Handlers::Bridge (e));
          add_bridge (t);
        }

        else if (n == ACE_TEXT("sharedResource"))
        {
          sharedResource_value_type t (new ::DAnCE::Config_Handlers::SharedResource (e));
          add_sharedResource (t);
        }

        else if (n == ACE_TEXT("infoProperty"))
        {
          infoProperty_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_infoProperty (t);
        }

        else
        {
        }
      }
    }

    // Bridge

    Bridge::
    Bridge (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = Bridge::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("label"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          label (t);
        }

        else if (n == ACE_TEXT("connect"))
        {
          connect_value_type t (new ::DAnCE::Config_Handlers::Interconnect (e));
          add_connect (t);
        }

        else if (n == ACE_TEXT("resource"))
        {
          resource_value_type t (new ::DAnCE::Config_Handlers::Resource (e));
          add_resource (t);
        }

        else
        {
        }
      }
    }

    // Interconnect

    Interconnect::
    Interconnect (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = Interconnect::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("label"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          label (t);
        }

        else if (n == ACE_TEXT("connection"))
        {
          connection_value_type t (new ::DAnCE::Config_Handlers::Bridge (e));
          add_connection (t);
        }

        else if (n == ACE_TEXT("connect"))
        {
          connect_value_type t (new ::DAnCE::Config_Handlers::Node (e));
          add_connect (t);
        }

        else if (n == ACE_TEXT("resource"))
        {
          resource_value_type t (new ::DAnCE::Config_Handlers::Resource (e));
          add_resource (t);
        }

        else
        {
        }
      }
    }

    // Node

    Node::
    Node (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = Node::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("label"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          label (t);
        }

        else if (n == ACE_TEXT("connection"))
        {
          connection_value_type t (new ::DAnCE::Config_Handlers::Interconnect (e));
          add_connection (t);
        }

        else if (n == ACE_TEXT("sharedResource"))
        {
          sharedResource_value_type t (new ::DAnCE::Config_Handlers::SharedResource (e));
          add_sharedResource (t);
        }

        else if (n == ACE_TEXT("resource"))
        {
          resource_value_type t (new ::DAnCE::Config_Handlers::Resource (e));
          add_resource (t);
        }

        else
        {
        }
      }
    }

    // SharedResource

    SharedResource::
    SharedResource (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = SharedResource::name_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("resourceType"))
        {
          resourceType_ = SharedResource::resourceType_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
          resourceType_->container (this);
        }

        else if (n == ACE_TEXT("node"))
        {
          node_ = SharedResource::node_auto_ptr_type (new ::DAnCE::Config_Handlers::Node (e));
          node_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          property_ = SharedResource::property_auto_ptr_type (new ::DAnCE::Config_Handlers::SatisfierProperty (e));
          property_->container (this);
        }

        else
        {
        }
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

