/*
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please report this to the XSC project at
 * https://github.com/DOCGroup/XSC
 */
#include "ccd.hpp"

#include "ace/ace_wchar.h"
#include "ace/Null_Mutex.h"
#include "ace/TSS_T.h"
#include "ace/Singleton.h"

namespace DAnCE
{
  namespace Config_Handlers
  {
    // ComponentInterfaceDescription

    ComponentInterfaceDescription::ComponentInterfaceDescription ()
    : ::XSCRT::Type ()
    {
    }

    ComponentInterfaceDescription::ComponentInterfaceDescription (ComponentInterfaceDescription const& s) :
    ::XSCRT::Type (s)
    , label_ (s.label_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.label_) : 0)
    , UUID_ (s.UUID_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.UUID_) : 0)
    , specificType_ (s.specificType_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.specificType_) : 0)
    , supportedType_ (s.supportedType_)
    , idlFile_ (s.idlFile_)
    , configProperty_ (s.configProperty_)
    , port_ (s.port_)
    , property_ (s.property_)
    , infoProperty_ (s.infoProperty_)
    , contentLocation_ (s.contentLocation_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.contentLocation_) : 0)
    , href_ (s.href_.get () ? new ::XMLSchema::string<ACE_TCHAR> (*s.href_) : 0)
    {
      if (label_.get ()) label_->container (this);
      if (UUID_.get ()) UUID_->container (this);
      if (specificType_.get ()) specificType_->container (this);
      if (contentLocation_.get ()) contentLocation_->container (this);
      if (href_.get ()) href_->container (this);
    }

    ComponentInterfaceDescription&
    ComponentInterfaceDescription::operator= (ComponentInterfaceDescription const& s)
    {
      if (&s != this)
      {
        if (s.label_.get ())
          label (*(s.label_));
        else
          label_.reset (0);

        if (s.UUID_.get ())
          UUID (*(s.UUID_));
        else
          UUID_.reset (0);

        if (s.specificType_.get ())
          specificType (*(s.specificType_));
        else
          specificType_.reset (0);

        supportedType_ = s.supportedType_;

        idlFile_ = s.idlFile_;

        configProperty_ = s.configProperty_;

        port_ = s.port_;

        property_ = s.property_;

        infoProperty_ = s.infoProperty_;

        if (s.contentLocation_.get ())
          contentLocation (*(s.contentLocation_));
        else
          contentLocation_.reset (0);

        if (s.href_.get ()) href (*(s.href_));
        else href_.reset (0);
      }

      return *this;
    }


    // ComponentInterfaceDescription
    bool ComponentInterfaceDescription::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ComponentInterfaceDescription::
    label () const
    {
      return *label_;
    }

    void ComponentInterfaceDescription::
    label (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = ComponentInterfaceDescription::label_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        label_->container (this);
      }
    }

    // ComponentInterfaceDescription
    bool ComponentInterfaceDescription::
    UUID_p () const
    {
      return UUID_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ComponentInterfaceDescription::
    UUID () const
    {
      return *UUID_;
    }

    void ComponentInterfaceDescription::
    UUID (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (UUID_.get ())
      {
        *UUID_ = e;
      }

      else
      {
        UUID_ = ComponentInterfaceDescription::UUID_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        UUID_->container (this);
      }
    }

    // ComponentInterfaceDescription
    bool ComponentInterfaceDescription::
    specificType_p () const
    {
      return specificType_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ComponentInterfaceDescription::
    specificType () const
    {
      return *specificType_;
    }

    void ComponentInterfaceDescription::
    specificType (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (specificType_.get ())
      {
        *specificType_ = e;
      }

      else
      {
        specificType_ = ComponentInterfaceDescription::specificType_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        specificType_->container (this);
      }
    }

    // ComponentInterfaceDescription
    ComponentInterfaceDescription::supportedType_iterator ComponentInterfaceDescription::
    begin_supportedType ()
    {
      return supportedType_.begin ();
    }

    ComponentInterfaceDescription::supportedType_iterator ComponentInterfaceDescription::
    end_supportedType ()
    {
      return supportedType_.end ();
    }

    ComponentInterfaceDescription::supportedType_const_iterator ComponentInterfaceDescription::
    begin_supportedType () const
    {
      return supportedType_.begin ();
    }

    ComponentInterfaceDescription::supportedType_const_iterator ComponentInterfaceDescription::
    end_supportedType () const
    {
      return supportedType_.end ();
    }

    void ComponentInterfaceDescription::
    add_supportedType (ComponentInterfaceDescription::supportedType_value_type const& e)
    {
      supportedType_.push_back (e);
    }

    size_t ComponentInterfaceDescription::
    count_supportedType(void) const
    {
      return supportedType_.size ();
    }

    // ComponentInterfaceDescription
    ComponentInterfaceDescription::idlFile_iterator ComponentInterfaceDescription::
    begin_idlFile ()
    {
      return idlFile_.begin ();
    }

    ComponentInterfaceDescription::idlFile_iterator ComponentInterfaceDescription::
    end_idlFile ()
    {
      return idlFile_.end ();
    }

    ComponentInterfaceDescription::idlFile_const_iterator ComponentInterfaceDescription::
    begin_idlFile () const
    {
      return idlFile_.begin ();
    }

    ComponentInterfaceDescription::idlFile_const_iterator ComponentInterfaceDescription::
    end_idlFile () const
    {
      return idlFile_.end ();
    }

    void ComponentInterfaceDescription::
    add_idlFile (ComponentInterfaceDescription::idlFile_value_type const& e)
    {
      idlFile_.push_back (e);
    }

    size_t ComponentInterfaceDescription::
    count_idlFile(void) const
    {
      return idlFile_.size ();
    }

    // ComponentInterfaceDescription
    ComponentInterfaceDescription::configProperty_iterator ComponentInterfaceDescription::
    begin_configProperty ()
    {
      return configProperty_.begin ();
    }

    ComponentInterfaceDescription::configProperty_iterator ComponentInterfaceDescription::
    end_configProperty ()
    {
      return configProperty_.end ();
    }

    ComponentInterfaceDescription::configProperty_const_iterator ComponentInterfaceDescription::
    begin_configProperty () const
    {
      return configProperty_.begin ();
    }

    ComponentInterfaceDescription::configProperty_const_iterator ComponentInterfaceDescription::
    end_configProperty () const
    {
      return configProperty_.end ();
    }

    void ComponentInterfaceDescription::
    add_configProperty (ComponentInterfaceDescription::configProperty_value_type const& e)
    {
      configProperty_.push_back (e);
    }

    size_t ComponentInterfaceDescription::
    count_configProperty(void) const
    {
      return configProperty_.size ();
    }

    // ComponentInterfaceDescription
    ComponentInterfaceDescription::port_iterator ComponentInterfaceDescription::
    begin_port ()
    {
      return port_.begin ();
    }

    ComponentInterfaceDescription::port_iterator ComponentInterfaceDescription::
    end_port ()
    {
      return port_.end ();
    }

    ComponentInterfaceDescription::port_const_iterator ComponentInterfaceDescription::
    begin_port () const
    {
      return port_.begin ();
    }

    ComponentInterfaceDescription::port_const_iterator ComponentInterfaceDescription::
    end_port () const
    {
      return port_.end ();
    }

    void ComponentInterfaceDescription::
    add_port (ComponentInterfaceDescription::port_value_type const& e)
    {
      port_.push_back (e);
    }

    size_t ComponentInterfaceDescription::
    count_port(void) const
    {
      return port_.size ();
    }

    // ComponentInterfaceDescription
    ComponentInterfaceDescription::property_iterator ComponentInterfaceDescription::
    begin_property ()
    {
      return property_.begin ();
    }

    ComponentInterfaceDescription::property_iterator ComponentInterfaceDescription::
    end_property ()
    {
      return property_.end ();
    }

    ComponentInterfaceDescription::property_const_iterator ComponentInterfaceDescription::
    begin_property () const
    {
      return property_.begin ();
    }

    ComponentInterfaceDescription::property_const_iterator ComponentInterfaceDescription::
    end_property () const
    {
      return property_.end ();
    }

    void ComponentInterfaceDescription::
    add_property (ComponentInterfaceDescription::property_value_type const& e)
    {
      property_.push_back (e);
    }

    size_t ComponentInterfaceDescription::
    count_property(void) const
    {
      return property_.size ();
    }

    // ComponentInterfaceDescription
    ComponentInterfaceDescription::infoProperty_iterator ComponentInterfaceDescription::
    begin_infoProperty ()
    {
      return infoProperty_.begin ();
    }

    ComponentInterfaceDescription::infoProperty_iterator ComponentInterfaceDescription::
    end_infoProperty ()
    {
      return infoProperty_.end ();
    }

    ComponentInterfaceDescription::infoProperty_const_iterator ComponentInterfaceDescription::
    begin_infoProperty () const
    {
      return infoProperty_.begin ();
    }

    ComponentInterfaceDescription::infoProperty_const_iterator ComponentInterfaceDescription::
    end_infoProperty () const
    {
      return infoProperty_.end ();
    }

    void ComponentInterfaceDescription::
    add_infoProperty (ComponentInterfaceDescription::infoProperty_value_type const& e)
    {
      infoProperty_.push_back (e);
    }

    size_t ComponentInterfaceDescription::
    count_infoProperty(void) const
    {
      return infoProperty_.size ();
    }

    // ComponentInterfaceDescription
    bool ComponentInterfaceDescription::
    contentLocation_p () const
    {
      return contentLocation_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ComponentInterfaceDescription::
    contentLocation () const
    {
      return *contentLocation_;
    }

    void ComponentInterfaceDescription::
    contentLocation (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (contentLocation_.get ())
      {
        *contentLocation_ = e;
      }

      else
      {
        contentLocation_ = ComponentInterfaceDescription::contentLocation_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        contentLocation_->container (this);
      }
    }

    // ComponentInterfaceDescription
    bool ComponentInterfaceDescription::
    href_p () const
    {
      return href_.get () != 0;
    }

    ::XMLSchema::string<ACE_TCHAR> const& ComponentInterfaceDescription::
    href () const
    {
      return *href_;
    }

    ::XMLSchema::string<ACE_TCHAR>& ComponentInterfaceDescription::
    href ()
    {
      return *href_;
    }

    void ComponentInterfaceDescription::
    href (::XMLSchema::string<ACE_TCHAR> const& e)
    {
      if (href_.get ())
      {
        *href_ = e;
      }

      else
      {
        href_ = ComponentInterfaceDescription::href_auto_ptr_type (new ::XMLSchema::string<ACE_TCHAR> (e));
        href_->container (this);
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    // ComponentInterfaceDescription

    ComponentInterfaceDescription::
    ComponentInterfaceDescription (::XSCRT::XML::Element<ACE_TCHAR> const& e)
    :Base (e)
    {

      ::XSCRT::Parser<ACE_TCHAR> p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element<ACE_TCHAR> e (p.next_element ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("label"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          label (t);
        }

        else if (n == ACE_TEXT("UUID"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          UUID (t);
        }

        else if (n == ACE_TEXT("specificType"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          specificType (t);
        }

        else if (n == ACE_TEXT("supportedType"))
        {
          supportedType_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_supportedType (t);
        }

        else if (n == ACE_TEXT("idlFile"))
        {
          idlFile_value_type t (new ::XMLSchema::string<ACE_TCHAR> (e));
          add_idlFile (t);
        }

        else if (n == ACE_TEXT("configProperty"))
        {
          configProperty_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_configProperty (t);
        }

        else if (n == ACE_TEXT("port"))
        {
          port_value_type t (new ::DAnCE::Config_Handlers::ComponentPortDescription (e));
          add_port (t);
        }

        else if (n == ACE_TEXT("property"))
        {
          property_value_type t (new ::DAnCE::Config_Handlers::ComponentPropertyDescription (e));
          add_property (t);
        }

        else if (n == ACE_TEXT("infoProperty"))
        {
          infoProperty_value_type t (new ::DAnCE::Config_Handlers::Property (e));
          add_infoProperty (t);
        }

        else if (n == ACE_TEXT("contentLocation"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (e);
          contentLocation (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute<ACE_TCHAR> a (p.next_attribute ());
        std::basic_string<ACE_TCHAR> n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("href"))
        {
          ::XMLSchema::string<ACE_TCHAR> t (a);
          href (t);
        }

        else
        {
        }
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

